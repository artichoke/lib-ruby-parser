// THIS FILE IS AUTO-GENERATED BY vendor/codegen.rb
#[macro_use]
mod assert_scanned;

#[test]
fn test_ambiguous_integer_re_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1re",
                    :tINTEGER,    "1",  [0, 1],
                    :tIDENTIFIER, "re", [1, 3]);
}

#[test]
fn test_ambiguous_uminus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "m -3",
                    :tIDENTIFIER, "m", [0, 1],
                    :tUNARY_NUM,  "-", [2, 3],
                    :tINTEGER,    "3", [3, 4]);
}

// skipping test_ambiguous_uplus_case_0

#[test]
fn test_and_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "&",
                    :tAMPER, "&", [0, 1]);
}

#[test]
fn test_and2_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "&&",
                    :tANDOP, "&&", [0, 2]);
}

#[test]
fn test_and2_equals_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "&&=",
                    :tOP_ASGN, "&&", [0, 3]);
}

#[test]
fn test_and_arg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " &y",
                    :tAMPER,      "&", [1, 2],
                    :tIDENTIFIER, "y", [2, 3]);
}

#[test]
fn test_and_dot_arg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "&.",
                    :tANDDOT, "&.", [0, 2]);
}

#[test]
fn test_and_dot_cmdarg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_CMDARG);
    assert_scanned!(&mut lexer,
                    "&.",
                    :tANDDOT, "&.", [0, 2]);
}

#[test]
fn test_and_equals_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "&=",
                    :tOP_ASGN, "&", [0, 2]);
}

#[test]
fn test_and_expr_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "x & y",
                    :tIDENTIFIER, "x", [0, 1],
                    :tAMPER2,     "&", [2, 3],
                    :tIDENTIFIER, "y", [4, 5]);
}

#[test]
fn test_assoc_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "=>",
                    :tASSOC, "=>", [0, 2]);
}

#[test]
fn test_back_ref_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "[$&, $`, $', $+]",
                    :tLBRACK,   "[",  [0, 1],
                    :tBACK_REF, "$&", [1, 3],
                    :tCOMMA,    ",",  [3, 4],
                    :tBACK_REF, "$`", [5, 7],
                    :tCOMMA,    ",",  [7, 8],
                    :tBACK_REF, "$'", [9, 11],
                    :tCOMMA,    ",",  [11, 12],
                    :tBACK_REF, "$+", [13, 15],
                    :tRBRACK,   "]",  [15, 16]);
}

#[test]
fn test_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1 \\\n+ 2",
                    :tINTEGER, "1", [0, 1],
                    :tPLUS,    "+", [4, 5],
                    :tINTEGER, "2", [6, 7]);
}

#[test]
fn test_backtick_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "`ls`",
                    :tXSTRING_BEG,    "`",  [0, 1],
                    :tSTRING_CONTENT, "ls", [1, 3],
                    :tSTRING_END,     "`",  [3, 4]);
}

#[test]
fn test_backtick_cmdarg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "\n`",
                    :tBACK_REF2, "`", [1, 2]);
}

#[test]
fn test_backtick_dot_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "a.`(3)",
                    :tIDENTIFIER, "a", [0, 1],
                    :tDOT,        ".", [1, 2],
                    :tBACK_REF2,  "`", [2, 3],
                    :tLPAREN2,    "(", [3, 4],
                    :tINTEGER,    "3", [4, 5],
                    :tRPAREN,     ")", [5, 6]);
}

#[test]
fn test_backtick_method_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "`",
                    :tBACK_REF2, "`", [0, 1]);
}

#[test]
fn test_bang_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "!",
                    :tBANG, "!", [0, 1]);
}

#[test]
fn test_bang_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "!=",
                    :tNEQ, "!=", [0, 2]);
}

#[test]
fn test_bang_tilde_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "!~",
                    :tNMATCH, "!~", [0, 2]);
}

#[test]
fn test_bug_407_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "123if cond",
                    :tINTEGER,    "123",  [0, 3],
                    :kIF_MOD,     "if",   [3, 5],
                    :tIDENTIFIER, "cond", [6, 10]);
}

#[test]
fn test_bug_407_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.23if cond",
                    :tFLOAT,      "1.23", [0, 4],
                    :kIF_MOD,     "if",   [4, 6],
                    :tIDENTIFIER, "cond", [7, 11]);
}

#[test]
fn test_bug_407_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "123rescue cond",
                    :tINTEGER,    "123",    [0, 3],
                    :kRESCUE_MOD, "rescue", [3, 9],
                    :tIDENTIFIER, "cond",   [10, 14]);
}

#[test]
fn test_bug_407_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.23rescue cond",
                    :tFLOAT,      "1.23",   [0, 4],
                    :kRESCUE_MOD, "rescue", [4, 10],
                    :tIDENTIFIER, "cond",   [11, 15]);
}

#[test]
fn test_bug_418_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{\n=begin\nx: 1,\n=end\ny: 2}",
                    :tLBRACE,  "{", [0, 1],
                    :tLABEL,   "y", [20, 22],
                    :tINTEGER, "2", [23, 24],
                    :tRCURLY,  "}", [24, 25]);
}

#[test]
fn test_bug_423_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    ":&&",
                    :tSYMBEG, ":",  [0, 1],
                    :tANDOP,  "&&", [1, 3]);
}

#[test]
fn test_bug_423_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    ":||",
                    :tSYMBEG, ":",  [0, 1],
                    :tOROP,   "||", [1, 3]);
}

#[test]
fn test_bug_const_e_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "E10",
                    :tCONSTANT, "E10", [0, 3]);
}

#[test]
fn test_bug_const_e_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "E4U",
                    :tCONSTANT, "E4U", [0, 3]);
}

#[test]
fn test_bug_const_expr_end_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "Option",
                    :tCONSTANT, "Option", [0, 6]);
}

#[test]
fn test_bug_eql_end_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "=begin\n#=end\n=end",
                    );
}

#[test]
fn test_bug_expr_arg_comment_newline_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " #\nfoo",
                    :tNL,         "",    [2, 3],
                    :tIDENTIFIER, "foo", [3, 6]);
}

#[test]
fn test_bug_expr_arg_eh_crlf_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " ?\r\n",
                    :tEH, "?", [1, 2]);
}

#[test]
fn test_bug_expr_arg_label_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " unless:",
                    :tLABEL, "unless", [1, 8]);
}

#[test]
fn test_bug_expr_arg_label_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " unless: ",
                    :tLABEL, "unless", [1, 8]);
}

#[test]
fn test_bug_expr_arg_lt_lt_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "<<EOS\nEOS",
                    :tLSHFT,    "<<",  [0, 2],
                    :tCONSTANT, "EOS", [2, 5],
                    :tNL,       "",    [5, 6],
                    :tCONSTANT, "EOS", [6, 9]);
}

#[test]
fn test_bug_expr_arg_lt_lt_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " <<EOS\nEOS",
                    :tSTRING_BEG, "<<\"", [1, 6],
                    :tSTRING_END, "EOS",  [7, 10],
                    :tNL,         "",     [6, 7]);
}

#[test]
fn test_bug_expr_arg_newline_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "\nfoo",
                    :tNL,         "",    [0, 1],
                    :tIDENTIFIER, "foo", [1, 4]);
}

#[test]
fn test_bug_expr_arg_newline_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " \nfoo",
                    :tNL,         "",    [1, 2],
                    :tIDENTIFIER, "foo", [2, 5]);
}

#[test]
fn test_bug_expr_arg_newline_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "#foo\nfoo",
                    :tNL,         "",    [4, 5],
                    :tIDENTIFIER, "foo", [5, 8]);
}

#[test]
fn test_bug_expr_arg_percent_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "%[",
                    :tPERCENT, "%", [0, 1],
                    :tLBRACK,  "[", [1, 2]);
}

#[test]
fn test_bug_expr_arg_percent_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "%=1",
                    :tOP_ASGN, "%", [0, 2],
                    :tINTEGER, "1", [2, 3]);
}

#[test]
fn test_bug_expr_arg_percent_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " %[1]",
                    :tSTRING_BEG,     "%[", [1, 3],
                    :tSTRING_CONTENT, "1",  [3, 4],
                    :tSTRING_END,     "]",  [4, 5]);
}

#[test]
fn test_bug_expr_arg_percent_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " %=1=",
                    :tOP_ASGN, "%", [1, 3],
                    :tINTEGER, "1", [3, 4],
                    :tEQL,     "=", [4, 5]);
}

#[test]
fn test_bug_expr_arg_percent_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " %\n",
                    :tPERCENT, "%", [1, 2]);
}

#[test]
fn test_bug_expr_arg_slash_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "/1",
                    :tDIVIDE,  "/", [0, 1],
                    :tINTEGER, "1", [1, 2]);
}

#[test]
fn test_bug_expr_arg_slash_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "/ 1",
                    :tDIVIDE,  "/", [0, 1],
                    :tINTEGER, "1", [2, 3]);
}

#[test]
fn test_bug_expr_arg_slash_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " /1/",
                    :tREGEXP_BEG,     "/", [1, 2],
                    :tSTRING_CONTENT, "1", [2, 3],
                    :tSTRING_END,     "/", [3, 4],
                    :tREGEXP_OPT,     "",  [4, 4]);
}

#[test]
fn test_bug_expr_arg_slash_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " / 1",
                    :tDIVIDE,  "/", [1, 2],
                    :tINTEGER, "1", [3, 4]);
}

#[test]
fn test_bug_expr_beg_backspace_nl_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "\n/foo/",
                    :tREGEXP_BEG,     "/",   [1, 2],
                    :tSTRING_CONTENT, "foo", [2, 5],
                    :tSTRING_END,     "/",   [5, 6],
                    :tREGEXP_OPT,     "",    [6, 6]);
}

#[test]
fn test_bug_expr_beg_div_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "/=/",
                    :tREGEXP_BEG,     "/", [0, 1],
                    :tSTRING_CONTENT, "=", [1, 2],
                    :tSTRING_END,     "/", [2, 3],
                    :tREGEXP_OPT,     "",  [3, 3]);
}

#[test]
fn test_bug_expr_beg_div_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "/ = /",
                    :tREGEXP_BEG,     "/",   [0, 1],
                    :tSTRING_CONTENT, " = ", [1, 4],
                    :tSTRING_END,     "/",   [4, 5],
                    :tREGEXP_OPT,     "",    [5, 5]);
}

#[test]
fn test_bug_expr_beg_document_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    " \n=begin\n=end\nend",
                    :kEND, "end", [14, 17]);
}

#[test]
fn test_bug_expr_beg_fid_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "Rainbows!",
                    :tFID, "Rainbows!", [0, 9]);
}

#[test]
fn test_bug_expr_beg_heredoc_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<EOL % [\nfoo\nEOL\n]",
                    :tSTRING_BEG,     "<<\"",  [0, 5],
                    :tSTRING_CONTENT, "foo\n", [10, 14],
                    :tSTRING_END,     "EOL",   [14, 17],
                    :tPERCENT,        "%",     [6, 7],
                    :tLBRACK,         "[",     [8, 9],
                    :tRBRACK,         "]",     [18, 19]);
}

#[test]
fn test_bug_expr_beg_number_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "86400_000_000",
                    :tINTEGER, "86400000000", [0, 13]);
}

#[test]
fn test_bug_expr_beg_percent_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "%=foo=",
                    :tSTRING_BEG,     "%=",  [0, 2],
                    :tSTRING_CONTENT, "foo", [2, 5],
                    :tSTRING_END,     "=",   [5, 6]);
}

#[test]
fn test_bug_expr_beg_percent_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "% = ",
                    :tSTRING_BEG,     "% ", [0, 2],
                    :tSTRING_CONTENT, "=",  [2, 3],
                    :tSTRING_END,     " ",  [3, 4]);
}

#[test]
fn test_bug_expr_beg_rescue_assoc_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "rescue=>",
                    :kRESCUE, "rescue", [0, 6],
                    :tASSOC,  "=>",     [6, 8]);
}

#[test]
fn test_bug_expr_dot_comment_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo. #bar\nbaz",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tDOT,        ".",   [3, 4],
                    :tIDENTIFIER, "baz", [10, 13]);
}

#[test]
fn test_bug_expr_dot_fid_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo.S?",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tDOT,        ".",   [3, 4],
                    :tFID,        "S?",  [4, 6]);
}

#[test]
fn test_bug_expr_dot_fid_mod_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo.x!if 1",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tDOT,        ".",   [3, 4],
                    :tFID,        "x!",  [4, 6],
                    :kIF_MOD,     "if",  [6, 8],
                    :tINTEGER,    "1",   [9, 10]);
}

#[test]
fn test_bug_expr_dot_id_eq_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo.x= 1",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tDOT,        ".",   [3, 4],
                    :tIDENTIFIER, "x",   [4, 5],
                    :tEQL,        "=",   [5, 6],
                    :tINTEGER,    "1",   [7, 8]);
}

#[test]
fn test_bug_expr_end_colon_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "'foo':'bar'",
                    :tSTRING, "foo", [0, 5],
                    :tCOLON,  ":",   [5, 6],
                    :tSTRING, "bar", [6, 11]);
}

#[test]
fn test_bug_expr_mid_bareword_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "begin; rescue rescue1",
                    :kBEGIN,      "begin",   [0, 5],
                    :tSEMI,       ";",       [5, 6],
                    :kRESCUE,     "rescue",  [7, 13],
                    :tIDENTIFIER, "rescue1", [14, 21]);
}

#[test]
fn test_bug_expr_mid_comment_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "rescue #bar\nprint",
                    :kRESCUE,     "rescue", [0, 6],
                    :tNL,         "",       [11, 12],
                    :tIDENTIFIER, "print",  [12, 17]);
}

#[test]
fn test_bug_expr_value_document_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1;\n=begin\n=end",
                    :tINTEGER, "1", [0, 1],
                    :tSEMI,    ";", [1, 2]);
}

#[test]
fn test_bug_expr_value_rescue_colon2_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_VALUE);
    assert_scanned!(&mut lexer,
                    "rescue::Exception",
                    :kRESCUE,   "rescue",    [0, 6],
                    :tCOLON3,   "::",        [6, 8],
                    :tCONSTANT, "Exception", [8, 17]);
}

#[test]
fn test_bug_fid_char_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "eof??a",
                    :tFID,       "eof?", [0, 4],
                    :tCHARACTER, "a",    [4, 6]);
}

#[test]
fn test_bug_heredoc_backspace_nl_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    " <<'XXX'\nf \\\nXXX\n",
                    :tSTRING_BEG,     "<<'",    [1, 8],
                    :tSTRING_CONTENT, "f \\\n", [9, 13],
                    :tSTRING_END,     "XXX",    [13, 16],
                    :tNL,             "",       [8, 9]);
}

#[test]
fn test_bug_heredoc_continuation_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " <<EOS\nEOS\nend",
                    :tSTRING_BEG, "<<\"", [1, 6],
                    :tSTRING_END, "EOS",  [7, 10],
                    :tNL,         "",     [6, 7],
                    :kEND,        "end",  [11, 14]);
}

#[test]
fn test_bug_heredoc_cr_lf_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<FIN\r\nfoo\r\nFIN\r\n",
                    :tSTRING_BEG,     "<<\"",  [0, 5],
                    :tSTRING_CONTENT, "foo\n", [6, 10],
                    :tSTRING_END,     "FIN",   [10, 13],
                    :tNL,             "",      [5, 6]);
}

#[test]
fn test_bug_heredoc_lshft_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<RULES << CLEANINGS\nRULES",
                    :tSTRING_BEG, "<<\"",      [0, 7],
                    :tSTRING_END, "RULES",     [21, 26],
                    :tLSHFT,      "<<",        [8, 10],
                    :tCONSTANT,   "CLEANINGS", [11, 20]);
}

#[test]
fn test_bug_hidden_eof_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "\"foo\u{0000}\u{001A}\u{0004}bar\"",
                    :tSTRING_BEG,     "\"",          [0, 1],
                    :tSTRING_CONTENT, "foo\u{0000}", [1, 5],
                    :tSTRING_CONTENT, "\u{001A}",    [5, 6],
                    :tSTRING_CONTENT, "\u{0004}",    [6, 7],
                    :tSTRING_CONTENT, "bar",         [7, 10],
                    :tSTRING_END,     "\"",          [10, 11]);
}

#[test]
fn test_bug_hidden_eof_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "'foo\u{0000}\u{001A}\u{0004}bar'",
                    :tSTRING_BEG,     "'",           [0, 1],
                    :tSTRING_CONTENT, "foo\u{0000}", [1, 5],
                    :tSTRING_CONTENT, "\u{001A}",    [5, 6],
                    :tSTRING_CONTENT, "\u{0004}",    [6, 7],
                    :tSTRING_CONTENT, "bar",         [7, 10],
                    :tSTRING_END,     "'",           [10, 11]);
}

#[test]
fn test_bug_hidden_eof_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "%w[foo\u{0000}\u{001A}\u{0004}bar]",
                    :tQWORDS_BEG,     "%w[",         [0, 3],
                    :tSTRING_CONTENT, "foo\u{0000}", [3, 7],
                    :tSTRING_CONTENT, "\u{001A}",    [7, 8],
                    :tSTRING_CONTENT, "\u{0004}",    [8, 9],
                    :tSTRING_CONTENT, "bar",         [9, 12],
                    :tSPACE,          "",            [12, 12],
                    :tSTRING_END,     "]",           [12, 13]);
}

#[test]
fn test_bug_hidden_eof_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "%W[foo\u{0000}\u{001A}\u{0004}bar]",
                    :tWORDS_BEG,      "%W[",         [0, 3],
                    :tSTRING_CONTENT, "foo\u{0000}", [3, 7],
                    :tSTRING_CONTENT, "\u{001A}",    [7, 8],
                    :tSTRING_CONTENT, "\u{0004}",    [8, 9],
                    :tSTRING_CONTENT, "bar",         [9, 12],
                    :tSPACE,          "",            [12, 12],
                    :tSTRING_END,     "]",           [12, 13]);
}

#[test]
fn test_bug_hidden_eof_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "# foo\u{0000}\nbar",
                    :tIDENTIFIER, "bar", [7, 10]);
}

// skipping test_bug_hidden_eof_case_5

#[test]
fn test_bug_line_begin_label_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo:bar",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tSYMBOL,     "bar", [3, 7]);
}

#[test]
fn test_bug_nonlabel_context_18_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1+a:a",
                    :tINTEGER,    "1", [0, 1],
                    :tPLUS,       "+", [1, 2],
                    :tIDENTIFIER, "a", [2, 3],
                    :tCOLON,      ":", [3, 4],
                    :tIDENTIFIER, "a", [4, 5]);
}

#[test]
fn test_bug_num_adj_kw_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1if",
                    :tINTEGER, "1",  [0, 1],
                    :kIF_MOD,  "if", [1, 3]);
}

#[test]
fn test_bug_num_adj_kw_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.0if",
                    :tFLOAT,  "1.0", [0, 3],
                    :kIF_MOD, "if",  [3, 5]);
}

#[test]
fn test_bug_sclass_comment_lshft_label_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "class # foo\n<< a:b;end",
                    :kCLASS,      "class", [0, 5],
                    :tLSHFT,      "<<",    [12, 14],
                    :tIDENTIFIER, "a",     [15, 16],
                    :tSYMBOL,     "b",     [16, 18],
                    :tSEMI,       ";",     [18, 19],
                    :kEND,        "end",   [19, 22]);
}

#[test]
fn test_bug_sclass_joined_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "class<<self",
                    :kCLASS, "class", [0, 5],
                    :tLSHFT, "<<",    [5, 7],
                    :kSELF,  "self",  [7, 11]);
}

#[test]
fn test_bug_semi_end_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo;\n__END__",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tSEMI,       ";",   [3, 4]);
}

// skipping test_bug_string_non_utf_case_0

#[test]
fn test_bug_string_non_utf_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"café\"",
                    :tSTRING, "café", [0, 7]);
}

#[test]
fn test_bug_string_non_utf_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"café\"",
                    :tSTRING, "café", [0, 6]);
}

#[test]
fn test_bug_string_percent_newline_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%\nfoo\n",
                    :tSTRING_BEG,     "%\n", [0, 2],
                    :tSTRING_CONTENT, "foo", [2, 5],
                    :tSTRING_END,     "\n",  [5, 6]);
}

#[test]
fn test_bug_string_percent_zero_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%\u{0000}foo\u{0000}",
                    :tSTRING_BEG,     "%\u{0000}", [0, 2],
                    :tSTRING_CONTENT, "foo",       [2, 5],
                    :tSTRING_END,     "\u{0000}",  [5, 6]);
}

#[test]
fn test_bug_string_utf_escape_composition_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\xE2\\x80\\x99\"",
                    :tSTRING, "’", [0, 14]);
}

#[test]
fn test_bug_string_utf_escape_composition_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\xE2\\x80\\x99\"",
                    :tSTRING, "’", [0, 14]);
}

#[test]
fn test_bug_string_utf_escape_composition_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\342\\200\\231\"",
                    :tSTRING, "’", [0, 14]);
}

#[test]
fn test_bug_string_utf_escape_composition_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\M-b\\C-\\M-@\\C-\\M-Y\"",
                    :tSTRING, "’", [0, 20]);
}

#[test]
fn test_bug_string_utf_escape_noop_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\あ\"",
                    :tSTRING, "あ", [0, 4]);
}

#[test]
fn test_bug_symbol_newline_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":foo\n",
                    :tSYMBOL, "foo", [0, 4],
                    :tNL,     "",    [4, 5]);
}

#[test]
fn test_bug_symbol_newline_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":foo=\n",
                    :tSYMBOL, "foo=", [0, 5],
                    :tNL,     "",     [5, 6]);
}

#[test]
fn test_bug_unicode_in_literal_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{00a4}\"",
                    :tSTRING, "¤", [0, 8]);
}

#[test]
fn test_bug_utf32le_leak_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"F0\"",
                    :tSTRING, "F0", [0, 4]);
}

#[test]
fn test_carat_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "^",
                    :tCARET, "^", [0, 1]);
}

#[test]
fn test_carat_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "^=",
                    :tOP_ASGN, "^", [0, 2]);
}

#[test]
fn test_colon2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "A::B",
                    :tCONSTANT, "A",  [0, 1],
                    :tCOLON2,   "::", [1, 3],
                    :tCONSTANT, "B",  [3, 4]);
}

#[test]
fn test_colon2_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "::Array",
                    :tCOLON2,   "::",    [0, 2],
                    :tCONSTANT, "Array", [2, 7]);
}

#[test]
fn test_colon3_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "::Array",
                    :tCOLON3,   "::",    [0, 2],
                    :tCONSTANT, "Array", [2, 7]);
}

#[test]
fn test_colon3_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " ::Array",
                    :tCOLON3,   "::",    [1, 3],
                    :tCONSTANT, "Array", [3, 8]);
}

#[test]
fn test_comma_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ",",
                    :tCOMMA, ",", [0, 1]);
}

#[test]
fn test_command_start_19_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "case a:b",
                    :kCASE,       "case", [0, 4],
                    :tIDENTIFIER, "a",    [5, 6],
                    :tSYMBOL,     "b",    [6, 8]);
}

#[test]
fn test_command_start_19_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "elsif a:b",
                    :kELSIF,      "elsif", [0, 5],
                    :tIDENTIFIER, "a",     [6, 7],
                    :tSYMBOL,     "b",     [7, 9]);
}

#[test]
fn test_command_start_19_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "for a:b",
                    :kFOR,        "for", [0, 3],
                    :tIDENTIFIER, "a",   [4, 5],
                    :tSYMBOL,     "b",   [5, 7]);
}

#[test]
fn test_command_start_19_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "in a:b",
                    :kIN,         "in", [0, 2],
                    :tIDENTIFIER, "a",  [3, 4],
                    :tSYMBOL,     "b",  [4, 6]);
}

#[test]
fn test_command_start_19_case_4() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "until a:b",
                    :kUNTIL,      "until", [0, 5],
                    :tIDENTIFIER, "a",     [6, 7],
                    :tSYMBOL,     "b",     [7, 9]);
}

#[test]
fn test_command_start_19_case_5() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "when a:b",
                    :kWHEN,       "when", [0, 4],
                    :tIDENTIFIER, "a",    [5, 6],
                    :tSYMBOL,     "b",    [6, 8]);
}

#[test]
fn test_command_start_19_case_6() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "while a:b",
                    :kWHILE,      "while", [0, 5],
                    :tIDENTIFIER, "a",     [6, 7],
                    :tSYMBOL,     "b",     [7, 9]);
}

#[test]
fn test_command_start_19_case_7() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "if a:b",
                    :kIF,         "if", [0, 2],
                    :tIDENTIFIER, "a",  [3, 4],
                    :tSYMBOL,     "b",  [4, 6]);
}

#[test]
fn test_command_start_19_case_8() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "unless a:b",
                    :kUNLESS,     "unless", [0, 6],
                    :tIDENTIFIER, "a",      [7, 8],
                    :tSYMBOL,     "b",      [8, 10]);
}

#[test]
fn test_command_start_19_case_9() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "and a:b",
                    :kAND,        "and", [0, 3],
                    :tIDENTIFIER, "a",   [4, 5],
                    :tSYMBOL,     "b",   [5, 7]);
}

#[test]
fn test_command_start_19_case_10() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "or a:b",
                    :kOR,         "or", [0, 2],
                    :tIDENTIFIER, "a",  [3, 4],
                    :tSYMBOL,     "b",  [4, 6]);
}

#[test]
fn test_comment_begin_not_comment_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "beginfoo = 5\np x \\\n=beginfoo",
                    :tIDENTIFIER, "beginfoo", [0, 8],
                    :tEQL,        "=",        [9, 10],
                    :tINTEGER,    "5",        [11, 12],
                    :tNL,         "",         [12, 13],
                    :tIDENTIFIER, "p",        [13, 14],
                    :tIDENTIFIER, "x",        [15, 16],
                    :tEQL,        "=",        [19, 20],
                    :tIDENTIFIER, "beginfoo", [20, 28]);
}

#[test]
fn test_comment_expr_beg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{#1\n}",
                    :tLBRACE, "{", [0, 1],
                    :tRCURLY, "}", [4, 5]);
}

#[test]
fn test_constant_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "ArgumentError",
                    :tCONSTANT, "ArgumentError", [0, 13]);
}

#[test]
fn test_constant_semi_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "ArgumentError;",
                    :tCONSTANT, "ArgumentError", [0, 13],
                    :tSEMI,     ";",             [13, 14]);
}

#[test]
fn test_cvar_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "@@blah",
                    :tCVAR, "@@blah", [0, 6]);
}

#[test]
fn test_def_ubang_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "!@",
                    :tBANG, "!@", [0, 2]);
}

#[test]
fn test_div_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a / 2",
                    :tIDENTIFIER, "a", [0, 1],
                    :tDIVIDE,     "/", [2, 3],
                    :tINTEGER,    "2", [4, 5]);
}

#[test]
fn test_div_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a /= 2",
                    :tIDENTIFIER, "a", [0, 1],
                    :tOP_ASGN,    "/", [2, 4],
                    :tINTEGER,    "2", [5, 6]);
}

#[test]
fn test_do_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "x do 42 end",
                    :tIDENTIFIER, "x",   [0, 1],
                    :kDO,         "do",  [2, 4],
                    :tINTEGER,    "42",  [5, 7],
                    :kEND,        "end", [8, 11]);
}

#[test]
fn test_dot_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ".",
                    :tDOT, ".", [0, 1]);
}

#[test]
fn test_endless_method_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "def foo() = 42",
                    :kDEF,        "def", [0, 3],
                    :tIDENTIFIER, "foo", [4, 7],
                    :tLPAREN2,    "(",   [7, 8],
                    :tRPAREN,     ")",   [8, 9],
                    :tEQL,        "=",   [10, 11],
                    :tINTEGER,    "42",  [12, 14]);
}

#[test]
fn test_eof_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "self",
                    :kSELF, "self", [0, 4]);
}

#[test]
fn test_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "=",
                    :tEQL, "=", [0, 1]);
}

#[test]
fn test_equals2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "==",
                    :tEQ, "==", [0, 2]);
}

#[test]
fn test_equals3_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "===",
                    :tEQQ, "===", [0, 3]);
}

#[test]
fn test_equals_tilde_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "=~",
                    :tMATCH, "=~", [0, 2]);
}

#[test]
fn test_escapes_in_squiggly_heredoc_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<~E\n\x07\x08\x1b\x0c\r\t\\\x0b\nE",
                    :tSTRING_BEG,     "<<\"",                       [0, 4],
                    :tSTRING_CONTENT, "\x07\x08\x1b\x0c\r\t\x0b\n", [5, 14],
                    :tSTRING_END,     "E",                          [14, 15],
                    :tNL,             "",                           [4, 5]);
}

#[test]
fn test_escapes_in_squiggly_heredoc_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<-E\n\x07\x08\x1b\x0c\r\t\\\x0b\nE",
                    :tSTRING_BEG,     "<<\"",                       [0, 4],
                    :tSTRING_CONTENT, "\x07\x08\x1b\x0c\r\t\x0b\n", [5, 14],
                    :tSTRING_END,     "E",                          [14, 15],
                    :tNL,             "",                           [4, 5]);
}

#[test]
fn test_float_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.0",
                    :tFLOAT, "1.0", [0, 3]);
}

#[test]
fn test_float_call_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.0.to_s",
                    :tFLOAT,      "1.0",  [0, 3],
                    :tDOT,        ".",    [3, 4],
                    :tIDENTIFIER, "to_s", [4, 8]);
}

#[test]
fn test_float_dot_e_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.0E10",
                    :tFLOAT, "1.0E10", [0, 6]);
}

#[test]
fn test_float_dot_e_upper_neg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-1.0E10",
                    :tUNARY_NUM, "-",      [0, 1],
                    :tFLOAT,     "1.0E10", [1, 7]);
}

// skipping test_float_dot_e_upper_pos_case_0

#[test]
fn test_float_dot_e_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.0e10",
                    :tFLOAT, "1.0e10", [0, 6]);
}

#[test]
fn test_float_dot_e_neg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-1.0e10",
                    :tUNARY_NUM, "-",      [0, 1],
                    :tFLOAT,     "1.0e10", [1, 7]);
}

// skipping test_float_dot_e_pos_case_0

#[test]
fn test_float_e_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e10",
                    :tFLOAT, "1e10", [0, 4]);
}

#[test]
fn test_float_e_minus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e-10",
                    :tFLOAT, "1e-10", [0, 5]);
}

#[test]
fn test_float_e_neg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-1e10",
                    :tUNARY_NUM, "-",    [0, 1],
                    :tFLOAT,     "1e10", [1, 5]);
}

#[test]
fn test_float_e_neg_minus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-1e-10",
                    :tUNARY_NUM, "-",     [0, 1],
                    :tFLOAT,     "1e-10", [1, 6]);
}

#[test]
fn test_float_e_neg_plus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-1e+10",
                    :tUNARY_NUM, "-",     [0, 1],
                    :tFLOAT,     "1e+10", [1, 6]);
}

#[test]
fn test_float_e_nothing_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1end",
                    :tINTEGER, "1",   [0, 1],
                    :kEND,     "end", [1, 4]);
}

#[test]
fn test_float_e_nothing_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.1end",
                    :tFLOAT, "1.1", [0, 3],
                    :kEND,   "end", [3, 6]);
}

#[test]
fn test_float_e_plus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e+10",
                    :tFLOAT, "1e+10", [0, 5]);
}

// skipping test_float_e_pos_case_0

// skipping test_float_e_pos_minus_case_0

// skipping test_float_e_pos_plus_case_0

#[test]
fn test_float_e_zero_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "0e0",
                    :tFLOAT, "0e0", [0, 3]);
}

#[test]
fn test_float_neg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-1.0",
                    :tUNARY_NUM, "-",   [0, 1],
                    :tFLOAT,     "1.0", [1, 4]);
}

// skipping test_float_pos_case_0

// skipping test_float_suffix_case_0

#[test]
fn test_float_suffix_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42.1if",
                    :tFLOAT,  "42.1", [0, 4],
                    :kIF_MOD, "if",   [4, 6]);
}

#[test]
fn test_float_suffix_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e1r",
                    :tFLOAT,      "1e1", [0, 3],
                    :tIDENTIFIER, "r",   [3, 4]);
}

// skipping test_float_suffix_case_3

#[test]
fn test_float_suffix_case_4() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42.1if",
                    :tFLOAT,  "42.1", [0, 4],
                    :kIF_MOD, "if",   [4, 6]);
}

#[test]
fn test_float_suffix_case_5() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e1r",
                    :tFLOAT,      "1e1", [0, 3],
                    :tIDENTIFIER, "r",   [3, 4]);
}

// skipping test_float_suffix_case_6

#[test]
fn test_float_suffix_case_7() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42.1if",
                    :tFLOAT,  "42.1", [0, 4],
                    :kIF_MOD, "if",   [4, 6]);
}

#[test]
fn test_float_suffix_case_8() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e1r",
                    :tFLOAT,      "1e1", [0, 3],
                    :tIDENTIFIER, "r",   [3, 4]);
}

#[test]
fn test_float_suffix_case_9() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42.1r",
                    :tRATIONAL, "42.1r", [0, 5]);
}

#[test]
fn test_float_suffix_case_10() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42.1i",
                    :tIMAGINARY, "42.1i", [0, 5]);
}

#[test]
fn test_float_suffix_case_11() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42.1ri",
                    :tIMAGINARY, "42.1ri", [0, 6]);
}

// skipping test_float_suffix_case_12

#[test]
fn test_float_suffix_case_13() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e1i",
                    :tIMAGINARY, "1e1i", [0, 4]);
}

#[test]
fn test_float_suffix_case_14() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e1r",
                    :tFLOAT,      "1e1", [0, 3],
                    :tIDENTIFIER, "r",   [3, 4]);
}

#[test]
fn test_float_suffix_case_15() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1e1ri",
                    :tFLOAT,      "1e1", [0, 3],
                    :tIDENTIFIER, "ri",  [3, 5]);
}

// skipping test_float_suffix_case_16

#[test]
fn test_fluent_and_dot_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "x\n&.y",
                    :tIDENTIFIER, "x",  [0, 1],
                    :tANDDOT,     "&.", [2, 4],
                    :tIDENTIFIER, "y",  [4, 5]);
}

#[test]
fn test_fluent_dot_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "x\n.y",
                    :tIDENTIFIER, "x", [0, 1],
                    :tDOT,        ".", [2, 3],
                    :tIDENTIFIER, "y", [3, 4]);
}

#[test]
fn test_fluent_dot_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "x\n  .y",
                    :tIDENTIFIER, "x", [0, 1],
                    :tDOT,        ".", [4, 5],
                    :tIDENTIFIER, "y", [5, 6]);
}

#[test]
fn test_fluent_dot_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "x # comment\n  .y",
                    :tIDENTIFIER, "x", [0, 1],
                    :tDOT,        ".", [14, 15],
                    :tIDENTIFIER, "y", [15, 16]);
}

#[test]
fn test_fname_pct_s_22_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "%s(a)",
                    :tPERCENT,    "%", [0, 1],
                    :tIDENTIFIER, "s", [1, 2],
                    :tLPAREN2,    "(", [2, 3],
                    :tIDENTIFIER, "a", [3, 4],
                    :tRPAREN,     ")", [4, 5]);
}

#[test]
fn test_fname_pct_s_23_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "%s(a)",
                    :tSYMBEG,         "%s(", [0, 3],
                    :tSTRING_CONTENT, "a",   [3, 4],
                    :tSTRING_END,     ")",   [4, 5]);
}

#[test]
fn test_ge_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a >= 2",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tGEQ,        ">=", [2, 4],
                    :tINTEGER,    "2",  [5, 6]);
}

#[test]
fn test_global_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$blah",
                    :tGVAR, "$blah", [0, 5]);
}

#[test]
fn test_global_backref_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$`",
                    :tBACK_REF, "$`", [0, 2]);
}

#[test]
fn test_global_dash_something_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$-x",
                    :tGVAR, "$-x", [0, 3]);
}

#[test]
fn test_global_number_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$10",
                    :tNTH_REF, "10", [0, 3]);
}

#[test]
fn test_global_other_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "[$~, $*, $$, $?, $!, $@, $/, $\\, $;, $,, $., $=, $:, $<, $>, $\"]",
                    :tLBRACK, "[",   [0, 1],
                    :tGVAR,   "$~",  [1, 3],
                    :tCOMMA,  ",",   [3, 4],
                    :tGVAR,   "$*",  [5, 7],
                    :tCOMMA,  ",",   [7, 8],
                    :tGVAR,   "$$",  [9, 11],
                    :tCOMMA,  ",",   [11, 12],
                    :tGVAR,   "$?",  [13, 15],
                    :tCOMMA,  ",",   [15, 16],
                    :tGVAR,   "$!",  [17, 19],
                    :tCOMMA,  ",",   [19, 20],
                    :tGVAR,   "$@",  [21, 23],
                    :tCOMMA,  ",",   [23, 24],
                    :tGVAR,   "$/",  [25, 27],
                    :tCOMMA,  ",",   [27, 28],
                    :tGVAR,   "$\\", [29, 31],
                    :tCOMMA,  ",",   [31, 32],
                    :tGVAR,   "$;",  [33, 35],
                    :tCOMMA,  ",",   [35, 36],
                    :tGVAR,   "$,",  [37, 39],
                    :tCOMMA,  ",",   [39, 40],
                    :tGVAR,   "$.",  [41, 43],
                    :tCOMMA,  ",",   [43, 44],
                    :tGVAR,   "$=",  [45, 47],
                    :tCOMMA,  ",",   [47, 48],
                    :tGVAR,   "$:",  [49, 51],
                    :tCOMMA,  ",",   [51, 52],
                    :tGVAR,   "$<",  [53, 55],
                    :tCOMMA,  ",",   [55, 56],
                    :tGVAR,   "$>",  [57, 59],
                    :tCOMMA,  ",",   [59, 60],
                    :tGVAR,   "$\"", [61, 63],
                    :tRBRACK, "]",   [63, 64]);
}

#[test]
fn test_global_underscore_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$_",
                    :tGVAR, "$_", [0, 2]);
}

#[test]
fn test_global_weird_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$__blah",
                    :tGVAR, "$__blah", [0, 7]);
}

#[test]
fn test_global_zero_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "$0",
                    :tGVAR, "$0", [0, 2]);
}

#[test]
fn test_gt_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a > 2",
                    :tIDENTIFIER, "a", [0, 1],
                    :tGT,         ">", [2, 3],
                    :tINTEGER,    "2", [4, 5]);
}

#[test]
fn test_heredoc_backtick_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<`EOF`\n  blah blah\nEOF\n",
                    :tIDENTIFIER,     "a",             [0, 1],
                    :tEQL,            "=",             [2, 3],
                    :tXSTRING_BEG,    "<<`",           [4, 11],
                    :tSTRING_CONTENT, "  blah blah\n", [12, 24],
                    :tSTRING_END,     "EOF",           [24, 27],
                    :tNL,             "",              [11, 12]);
}

#[test]
fn test_heredoc_cr_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<E\r\r\nABCDEF\r\r\nE\r\r\r\n",
                    :tIDENTIFIER,     "a",          [0, 1],
                    :tEQL,            "=",          [2, 3],
                    :tSTRING_BEG,     "<<\"",       [4, 7],
                    :tSTRING_CONTENT, "ABCDEF\r\n", [9, 17],
                    :tSTRING_END,     "E",          [17, 20],
                    :tNL,             "",           [8, 9]);
}

#[test]
fn test_heredoc_double_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<\"EOF\"\n  blah blah\nEOF\n",
                    :tIDENTIFIER,     "a",             [0, 1],
                    :tEQL,            "=",             [2, 3],
                    :tSTRING_BEG,     "<<\"",          [4, 11],
                    :tSTRING_CONTENT, "  blah blah\n", [12, 24],
                    :tSTRING_END,     "EOF",           [24, 27],
                    :tNL,             "",              [11, 12]);
}

#[test]
fn test_heredoc_double_dash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<-\"EOF\"\n  blah blah\n  EOF\n",
                    :tIDENTIFIER,     "a",             [0, 1],
                    :tEQL,            "=",             [2, 3],
                    :tSTRING_BEG,     "<<\"",          [4, 12],
                    :tSTRING_CONTENT, "  blah blah\n", [13, 25],
                    :tSTRING_END,     "EOF",           [25, 30],
                    :tNL,             "",              [12, 13]);
}

#[test]
fn test_heredoc_none_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<EOF\nblah\nblah\nEOF",
                    :tIDENTIFIER,     "a",      [0, 1],
                    :tEQL,            "=",      [2, 3],
                    :tSTRING_BEG,     "<<\"",   [4, 9],
                    :tSTRING_CONTENT, "blah\n", [10, 15],
                    :tSTRING_CONTENT, "blah\n", [15, 20],
                    :tSTRING_END,     "EOF",    [20, 23],
                    :tNL,             "",       [9, 10]);
}

#[test]
fn test_heredoc_none_dash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<-EOF\nblah\nblah\n  EOF",
                    :tIDENTIFIER,     "a",      [0, 1],
                    :tEQL,            "=",      [2, 3],
                    :tSTRING_BEG,     "<<\"",   [4, 10],
                    :tSTRING_CONTENT, "blah\n", [11, 16],
                    :tSTRING_CONTENT, "blah\n", [16, 21],
                    :tSTRING_END,     "EOF",    [21, 26],
                    :tNL,             "",       [10, 11]);
}

#[test]
fn test_heredoc_one_character_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<E\nABCDEF\nE\n",
                    :tIDENTIFIER,     "a",        [0, 1],
                    :tEQL,            "=",        [2, 3],
                    :tSTRING_BEG,     "<<\"",     [4, 7],
                    :tSTRING_CONTENT, "ABCDEF\n", [8, 15],
                    :tSTRING_END,     "E",        [15, 16],
                    :tNL,             "",         [7, 8]);
}

#[test]
fn test_heredoc_single_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<'EOF'\n  blah blah\nEOF\n",
                    :tIDENTIFIER,     "a",             [0, 1],
                    :tEQL,            "=",             [2, 3],
                    :tSTRING_BEG,     "<<'",           [4, 11],
                    :tSTRING_CONTENT, "  blah blah\n", [12, 24],
                    :tSTRING_END,     "EOF",           [24, 27],
                    :tNL,             "",              [11, 12]);
}

#[test]
fn test_heredoc_single_dash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<-'EOF'\n  blah blah\n  EOF\n",
                    :tIDENTIFIER,     "a",             [0, 1],
                    :tEQL,            "=",             [2, 3],
                    :tSTRING_BEG,     "<<'",           [4, 12],
                    :tSTRING_CONTENT, "  blah blah\n", [13, 25],
                    :tSTRING_END,     "EOF",           [25, 30],
                    :tNL,             "",              [12, 13]);
}

#[test]
fn test_heredoc_with_identifier_ending_newline_24_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a = <<\"EOS\n\"\nABCDEF\nEOS\n",
                    :tIDENTIFIER,     "a",        [0, 1],
                    :tEQL,            "=",        [2, 3],
                    :tSTRING_BEG,     "<<\"",     [4, 12],
                    :tSTRING_CONTENT, "ABCDEF\n", [13, 20],
                    :tSTRING_END,     "EOS",      [20, 23],
                    :tNL,             "",         [12, 13]);
}

#[test]
fn test_identifier_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "identifier",
                    :tIDENTIFIER, "identifier", [0, 10]);
}

#[test]
fn test_identifier_bang_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "identifier!",
                    :tFID, "identifier!", [0, 11]);
}

#[test]
fn test_identifier_bang_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "identifier!=",
                    :tIDENTIFIER, "identifier", [0, 10],
                    :tNEQ,        "!=",         [10, 12]);
}

#[test]
fn test_identifier_eh_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "identifier?",
                    :tFID, "identifier?", [0, 11]);
}

#[test]
fn test_identifier_eh_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "identifier?=",
                    :tIDENTIFIER, "identifier", [0, 10],
                    :tCHARACTER,  "=",          [10, 12]);
}

#[test]
fn test_identifier_equals3_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":a===b",
                    :tSYMBOL,     "a",   [0, 2],
                    :tEQQ,        "===", [2, 5],
                    :tIDENTIFIER, "b",   [5, 6]);
}

#[test]
fn test_identifier_equals_arrow_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":blah==>",
                    :tSYMBOL, "blah=", [0, 6],
                    :tASSOC,  "=>",    [6, 8]);
}

#[test]
fn test_identifier_equals_equals_arrow_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":a==>b",
                    :tSYMBOL,     "a=", [0, 3],
                    :tASSOC,      "=>", [3, 5],
                    :tIDENTIFIER, "b",  [5, 6]);
}

#[test]
fn test_identifier_equals_expr_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "y = arg",
                    :tIDENTIFIER, "y",   [0, 1],
                    :tEQL,        "=",   [2, 3],
                    :tIDENTIFIER, "arg", [4, 7]);
}

// skipping test_identifier_equals_tilde_case_0

#[test]
fn test_if_stmt_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "if true\n return end",
                    :kIF,     "if",     [0, 2],
                    :kTRUE,   "true",   [3, 7],
                    :tNL,     "",       [7, 8],
                    :kRETURN, "return", [9, 15],
                    :kEND,    "end",    [16, 19]);
}

#[test]
fn test_if_unless_mod_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "return if true unless false",
                    :kRETURN,     "return", [0, 6],
                    :kIF_MOD,     "if",     [7, 9],
                    :kTRUE,       "true",   [10, 14],
                    :kUNLESS_MOD, "unless", [15, 21],
                    :kFALSE,      "false",  [22, 27]);
}

// skipping test_int_suffix_case_0

#[test]
fn test_int_suffix_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42if",
                    :tINTEGER, "42", [0, 2],
                    :kIF_MOD,  "if", [2, 4]);
}

// skipping test_int_suffix_case_2

#[test]
fn test_int_suffix_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42if",
                    :tINTEGER, "42", [0, 2],
                    :kIF_MOD,  "if", [2, 4]);
}

// skipping test_int_suffix_case_4

#[test]
fn test_int_suffix_case_5() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42if",
                    :tINTEGER, "42", [0, 2],
                    :kIF_MOD,  "if", [2, 4]);
}

#[test]
fn test_int_suffix_case_6() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42r",
                    :tRATIONAL, "42r", [0, 3]);
}

#[test]
fn test_int_suffix_case_7() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42i",
                    :tIMAGINARY, "42i", [0, 3]);
}

#[test]
fn test_int_suffix_case_8() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42ri",
                    :tIMAGINARY, "42ri", [0, 4]);
}

#[test]
fn test_integer_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42",
                    :tINTEGER, "42", [0, 2]);
}

#[test]
fn test_integer_bin_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "0b101010",
                    :tINTEGER, "0b101010", [0, 8]);
}

#[test]
fn test_integer_dec_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "42",
                    :tINTEGER, "42", [0, 2]);
}

#[test]
fn test_integer_dec_d_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "0d42",
                    :tINTEGER, "0d42", [0, 4]);
}

#[test]
fn test_integer_hex_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "0x2a",
                    :tINTEGER, "0x2a", [0, 4]);
}

#[test]
fn test_integer_oct_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "052",
                    :tINTEGER, "052", [0, 3]);
}

#[test]
fn test_integer_trailing_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1.to_s",
                    :tINTEGER,    "1",    [0, 1],
                    :tDOT,        ".",    [1, 2],
                    :tIDENTIFIER, "to_s", [2, 6]);
}

#[test]
fn test_integer_underscore_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "4_2",
                    :tINTEGER, "42", [0, 3]);
}

#[test]
fn test_integer_zero_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "0",
                    :tINTEGER, "0", [0, 1]);
}

#[test]
fn test_ivar_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "@blah",
                    :tIVAR, "@blah", [0, 5]);
}

#[test]
fn test_keyword_expr_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    "if",
                    :kIF_MOD, "if", [0, 2]);
}

#[test]
fn test_label_19_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{a:b",
                    :tLBRACE,     "{", [0, 1],
                    :tLABEL,      "a", [1, 3],
                    :tIDENTIFIER, "b", [3, 4]);
}

#[test]
fn test_label_22_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{'a':",
                    :tLBRACE,         "{", [0, 1],
                    :tSTRING_BEG,     "'", [1, 2],
                    :tSTRING_CONTENT, "a", [2, 3],
                    :tLABEL_END,      "'", [3, 5]);
}

#[test]
fn test_label_colon2_22_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{'a'::",
                    :tLBRACE, "{",  [0, 1],
                    :tSTRING, "a",  [1, 4],
                    :tCOLON2, "::", [4, 6]);
}

#[test]
fn test_label_fid_19_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{a?:true",
                    :tLBRACE, "{",    [0, 1],
                    :tLABEL,  "a?",   [1, 4],
                    :kTRUE,   "true", [4, 8]);
}

#[test]
fn test_label_in_params_19_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "foo(a:b",
                    :tIDENTIFIER, "foo", [0, 3],
                    :tLPAREN2,    "(",   [3, 4],
                    :tLABEL,      "a",   [4, 6],
                    :tIDENTIFIER, "b",   [6, 7]);
}

#[test]
fn test_label_nested_22_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{'a\":':",
                    :tLBRACE,         "{",    [0, 1],
                    :tSTRING_BEG,     "'",    [1, 2],
                    :tSTRING_CONTENT, "a\":", [2, 5],
                    :tLABEL_END,      "'",    [5, 7]);
}

#[test]
fn test_lt_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<",
                    :tLT, "<", [0, 1]);
}

#[test]
fn test_lt2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a << b",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tLSHFT,      "<<", [2, 4],
                    :tIDENTIFIER, "b",  [5, 6]);
}

#[test]
fn test_lt2_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a <<= b",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tOP_ASGN,    "<<", [2, 5],
                    :tIDENTIFIER, "b",  [6, 7]);
}

#[test]
fn test_lt_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<=",
                    :tLEQ, "<=", [0, 2]);
}

#[test]
fn test_minus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1 - 2",
                    :tINTEGER, "1", [0, 1],
                    :tMINUS,   "-", [2, 3],
                    :tINTEGER, "2", [4, 5]);
}

#[test]
fn test_minus_equals_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "-=",
                    :tOP_ASGN, "-", [0, 2]);
}

#[test]
fn test_minus_method_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "-",
                    :tMINUS, "-", [0, 1]);
}

#[test]
fn test_minus_unary_method_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "-@",
                    :tUMINUS, "-@", [0, 2]);
}

#[test]
fn test_minus_unary_number_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-42",
                    :tUNARY_NUM, "-",  [0, 1],
                    :tINTEGER,   "42", [1, 3]);
}

// skipping test_minus_unary_whitespace_number_case_0

#[test]
fn test_mod_not_command_start_19_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "if a:b",
                    :kIF_MOD,     "if", [0, 2],
                    :tLABEL,      "a",  [3, 5],
                    :tIDENTIFIER, "b",  [5, 6]);
}

#[test]
fn test_mod_not_command_start_19_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "unless a:b",
                    :kUNLESS_MOD, "unless", [0, 6],
                    :tLABEL,      "a",      [7, 9],
                    :tIDENTIFIER, "b",      [9, 10]);
}

#[test]
fn test_mod_not_command_start_19_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "while a:b",
                    :kWHILE_MOD,  "while", [0, 5],
                    :tLABEL,      "a",     [6, 8],
                    :tIDENTIFIER, "b",     [8, 9]);
}

#[test]
fn test_mod_not_command_start_19_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "until a:b",
                    :kUNTIL_MOD,  "until", [0, 5],
                    :tLABEL,      "a",     [6, 8],
                    :tIDENTIFIER, "b",     [8, 9]);
}

#[test]
fn test_mod_not_command_start_19_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "rescue a:b",
                    :kRESCUE_MOD, "rescue", [0, 6],
                    :tLABEL,      "a",      [7, 9],
                    :tIDENTIFIER, "b",      [9, 10]);
}

#[test]
fn test_nth_ref_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "[$1, $2, $3]",
                    :tLBRACK,  "[", [0, 1],
                    :tNTH_REF, "1", [1, 3],
                    :tCOMMA,   ",", [3, 4],
                    :tNTH_REF, "2", [5, 7],
                    :tCOMMA,   ",", [7, 8],
                    :tNTH_REF, "3", [9, 11],
                    :tRBRACK,  "]", [11, 12]);
}

#[test]
fn test_open_bracket_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "(",
                    :tLPAREN, "(", [0, 1]);
}

#[test]
fn test_open_bracket_cmdarg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "m (",
                    :tIDENTIFIER, "m", [0, 1],
                    :tLPAREN_ARG, "(", [2, 3]);
}

#[test]
fn test_open_bracket_exprarg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "m(",
                    :tIDENTIFIER, "m", [0, 1],
                    :tLPAREN2,    "(", [1, 2]);
}

#[test]
fn test_open_curly_bracket_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{",
                    :tLBRACE, "{", [0, 1]);
}

#[test]
fn test_open_curly_bracket_arg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "m { 3 }",
                    :tIDENTIFIER, "m", [0, 1],
                    :tLCURLY,     "{", [2, 3],
                    :tINTEGER,    "3", [4, 5],
                    :tRCURLY,     "}", [6, 7]);
}

#[test]
fn test_open_curly_bracket_block_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    "{ 4 }",
                    :tLBRACE_ARG, "{", [0, 1],
                    :tINTEGER,    "4", [2, 3],
                    :tRCURLY,     "}", [4, 5]);
}

#[test]
fn test_open_square_bracket_arg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "m [ 3 ]",
                    :tIDENTIFIER, "m", [0, 1],
                    :tLBRACK,     "[", [2, 3],
                    :tINTEGER,    "3", [4, 5],
                    :tRBRACK,     "]", [6, 7]);
}

#[test]
fn test_open_square_bracket_ary_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "[1, 2, 3]",
                    :tLBRACK,  "[", [0, 1],
                    :tINTEGER, "1", [1, 2],
                    :tCOMMA,   ",", [2, 3],
                    :tINTEGER, "2", [4, 5],
                    :tCOMMA,   ",", [5, 6],
                    :tINTEGER, "3", [7, 8],
                    :tRBRACK,  "]", [8, 9]);
}

#[test]
fn test_open_square_bracket_meth_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "m[3]",
                    :tIDENTIFIER, "m", [0, 1],
                    :tLBRACK2,    "[", [1, 2],
                    :tINTEGER,    "3", [2, 3],
                    :tRBRACK,     "]", [3, 4]);
}

#[test]
fn test_or_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "|",
                    :tPIPE, "|", [0, 1]);
}

// skipping test_or2_after_27_case_0

#[test]
fn test_or2_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "||=",
                    :tOP_ASGN, "||", [0, 3]);
}

#[test]
fn test_or_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "|=",
                    :tOP_ASGN, "|", [0, 2]);
}

#[test]
fn test_parser_bug_486_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":!@",
                    :tSYMBOL, "!", [0, 3]);
}

#[test]
fn test_parser_bug_486_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":~@",
                    :tSYMBOL, "~", [0, 3]);
}

#[test]
fn test_pct_string_colon_22_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "{%'a':",
                    :tLBRACE,         "{",  [0, 1],
                    :tSTRING_BEG,     "%'", [1, 3],
                    :tSTRING_CONTENT, "a",  [3, 4],
                    :tSTRING_END,     "'",  [4, 5],
                    :tCOLON,          ":",  [5, 6]);
}

#[test]
fn test_percent_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a % 2",
                    :tIDENTIFIER, "a", [0, 1],
                    :tPERCENT,    "%", [2, 3],
                    :tINTEGER,    "2", [4, 5]);
}

#[test]
fn test_percent_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a %= 2",
                    :tIDENTIFIER, "a", [0, 1],
                    :tOP_ASGN,    "%", [2, 4],
                    :tINTEGER,    "2", [5, 6]);
}

#[test]
fn test_plus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "1 + 1",
                    :tINTEGER, "1", [0, 1],
                    :tPLUS,    "+", [2, 3],
                    :tINTEGER, "1", [4, 5]);
}

#[test]
fn test_plus_equals_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "+=",
                    :tOP_ASGN, "+", [0, 2]);
}

#[test]
fn test_plus_method_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "+",
                    :tPLUS, "+", [0, 1]);
}

#[test]
fn test_plus_unary_method_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "+@",
                    :tUPLUS, "+@", [0, 2]);
}

// skipping test_plus_unary_number_case_0

// skipping test_plus_unary_whitespace_number_case_0

#[test]
fn test_question_18_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?*",
                    :tINTEGER, "42", [0, 2]);
}

#[test]
fn test_question_19_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?*",
                    :tCHARACTER, "*", [0, 2]);
}

#[test]
fn test_question_bad_ws_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "? ",
                    :tEH, "?", [0, 1]);
}

#[test]
fn test_question_bad_ws_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\n",
                    :tEH, "?", [0, 1]);
}

#[test]
fn test_question_bad_ws_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\t",
                    :tEH, "?", [0, 1]);
}

#[test]
fn test_question_bad_ws_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\x0b",
                    :tEH, "?", [0, 1]);
}

#[test]
fn test_question_bad_ws_case_4() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\r",
                    :tEH, "?", [0, 1]);
}

#[test]
fn test_question_bad_ws_case_5() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\x0c",
                    :tEH, "?", [0, 1]);
}

#[test]
fn test_question_eh_a_18_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?a",
                    :tINTEGER, "97", [0, 2]);
}

#[test]
fn test_question_eh_a_19_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?a",
                    :tCHARACTER, "a", [0, 2]);
}

#[test]
fn test_question_eh_escape_m_upper_escape_c_upper_18_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\\M-\\C-a",
                    :tINTEGER, "129", [0, 8]);
}

// skipping test_question_eh_escape_m_upper_escape_c_upper_19_case_0

#[test]
fn test_question_eh_escape_space_around_unicode_point_24_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{ 1}\"",
                    :tSTRING, "\u{0001}", [0, 8]);
}

#[test]
fn test_question_eh_escape_space_around_unicode_point_24_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{1 }\"",
                    :tSTRING, "\u{0001}", [0, 8]);
}

#[test]
fn test_question_eh_escape_space_around_unicode_point_24_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{ 1 }\"",
                    :tSTRING, "\u{0001}", [0, 9]);
}

#[test]
fn test_question_eh_escape_space_around_unicode_point_24_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{1 2 }\"",
                    :tSTRING, "\u{0001}\u{0002}", [0, 10]);
}

#[test]
fn test_question_eh_escape_space_around_unicode_point_24_case_4() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{ 1 2}\"",
                    :tSTRING, "\u{0001}\u{0002}", [0, 10]);
}

#[test]
fn test_question_eh_escape_space_around_unicode_point_24_case_5() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\u{1  2}\"",
                    :tSTRING, "\u{0001}\u{0002}", [0, 10]);
}

#[test]
fn test_question_eh_escape_u_4_digits_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\\u{0001}",
                    :tCHARACTER, "\u{0001}", [0, 7]);
}

#[test]
fn test_question_eh_single_unicode_point_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\\u{123}",
                    :tCHARACTER, "ģ", [0, 8]);
}

#[test]
fn test_question_eh_single_unicode_point_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "?\\u{a}",
                    :tCHARACTER, "\n", [0, 6]);
}

#[test]
fn test_question_ws_backslashed_18_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\ ",
                    :tINTEGER, "32", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_18_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\n",
                    :tINTEGER, "10", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_18_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\t",
                    :tINTEGER, "9", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_18_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\x0b",
                    :tINTEGER, "11", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_18_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\r",
                    :tINTEGER, "13", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_18_case_5() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\x0c",
                    :tINTEGER, "12", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_19_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\ ",
                    :tCHARACTER, " ", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_19_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\n",
                    :tCHARACTER, "\n", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_19_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\t",
                    :tCHARACTER, "\t", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_19_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\x0b",
                    :tCHARACTER, "\x0b", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_19_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\r",
                    :tCHARACTER, "\r", [0, 3]);
}

#[test]
fn test_question_ws_backslashed_19_case_5() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "?\\x0c",
                    :tCHARACTER, "\x0c", [0, 3]);
}

#[test]
fn test_rbracket_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "]",
                    :tRBRACK, "]", [0, 1]);
}

// skipping test_rcurly_case_0

#[test]
fn test_regexp_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regexp/",
                    :tREGEXP_BEG,     "/",      [0, 1],
                    :tSTRING_CONTENT, "regexp", [1, 7],
                    :tSTRING_END,     "/",      [7, 8],
                    :tREGEXP_OPT,     "",       [8, 8]);
}

#[test]
fn test_regexp_ambiguous_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "method /regexp/",
                    :tIDENTIFIER,     "method", [0, 6],
                    :tREGEXP_BEG,     "/",      [7, 8],
                    :tSTRING_CONTENT, "regexp", [8, 14],
                    :tSTRING_END,     "/",      [14, 15],
                    :tREGEXP_OPT,     "",       [15, 15]);
}

#[test]
fn test_regexp_escape_c_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\C-x/",
                    :tREGEXP_BEG,     "/",          [0, 1],
                    :tSTRING_CONTENT, "regex\\C-x", [1, 10],
                    :tSTRING_END,     "/",          [10, 11],
                    :tREGEXP_OPT,     "",           [11, 11]);
}

#[test]
fn test_regexp_escape_c_upper_m_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\C-\\M-x/",
                    :tREGEXP_BEG,     "/",              [0, 1],
                    :tSTRING_CONTENT, "regex\\C-\\M-x", [1, 13],
                    :tSTRING_END,     "/",              [13, 14],
                    :tREGEXP_OPT,     "",               [14, 14]);
}

#[test]
fn test_regexp_escape_c_upper_m_upper_craaaazy_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\C-\\\n\\M-x/",
                    :tREGEXP_BEG,     "/",              [0, 1],
                    :tSTRING_CONTENT, "regex\\C-\\M-x", [1, 15],
                    :tSTRING_END,     "/",              [15, 16],
                    :tREGEXP_OPT,     "",               [16, 16]);
}

#[test]
fn test_regexp_escape_m_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\M-x/",
                    :tREGEXP_BEG,     "/",          [0, 1],
                    :tSTRING_CONTENT, "regex\\M-x", [1, 10],
                    :tSTRING_END,     "/",          [10, 11],
                    :tREGEXP_OPT,     "",           [11, 11]);
}

#[test]
fn test_regexp_escape_m_upper_c_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\M-\\C-x/",
                    :tREGEXP_BEG,     "/",              [0, 1],
                    :tSTRING_CONTENT, "regex\\M-\\C-x", [1, 13],
                    :tSTRING_END,     "/",              [13, 14],
                    :tREGEXP_OPT,     "",               [14, 14]);
}

#[test]
fn test_regexp_escape_backslash_slash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/\\//",
                    :tREGEXP_BEG,     "/", [0, 1],
                    :tSTRING_CONTENT, "/", [1, 3],
                    :tSTRING_END,     "/", [3, 4],
                    :tREGEXP_OPT,     "",  [4, 4]);
}

#[test]
fn test_regexp_escape_backslash_terminator_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%r%blah\\%blah%",
                    :tREGEXP_BEG,     "%r%",       [0, 3],
                    :tSTRING_CONTENT, "blah%blah", [3, 13],
                    :tSTRING_END,     "%",         [13, 14],
                    :tREGEXP_OPT,     "",          [14, 14]);
}

#[test]
fn test_regexp_escape_backslash_terminator_meta1_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%r{blah\\}blah}",
                    :tREGEXP_BEG,     "%r{",         [0, 3],
                    :tSTRING_CONTENT, "blah\\}blah", [3, 13],
                    :tSTRING_END,     "}",           [13, 14],
                    :tREGEXP_OPT,     "",            [14, 14]);
}

#[test]
fn test_regexp_escape_backslash_terminator_meta2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%r/blah\\/blah/",
                    :tREGEXP_BEG,     "%r/",       [0, 3],
                    :tSTRING_CONTENT, "blah/blah", [3, 13],
                    :tSTRING_END,     "/",         [13, 14],
                    :tREGEXP_OPT,     "",          [14, 14]);
}

#[test]
fn test_regexp_escape_backslash_terminator_meta3_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%r/blah\\%blah/",
                    :tREGEXP_BEG,     "%r/",         [0, 3],
                    :tSTRING_CONTENT, "blah\\%blah", [3, 13],
                    :tSTRING_END,     "/",           [13, 14],
                    :tREGEXP_OPT,     "",            [14, 14]);
}

#[test]
fn test_regexp_escape_bs_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\\\regex/",
                    :tREGEXP_BEG,     "/",              [0, 1],
                    :tSTRING_CONTENT, "regex\\\\regex", [1, 13],
                    :tSTRING_END,     "/",              [13, 14],
                    :tREGEXP_OPT,     "",               [14, 14]);
}

#[test]
fn test_regexp_escape_c_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\cxxx/",
                    :tREGEXP_BEG,     "/",           [0, 1],
                    :tSTRING_CONTENT, "regex\\cxxx", [1, 11],
                    :tSTRING_END,     "/",           [11, 12],
                    :tREGEXP_OPT,     "",            [12, 12]);
}

#[test]
fn test_regexp_escape_c_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\c\\n/",
                    :tREGEXP_BEG,     "/",           [0, 1],
                    :tSTRING_CONTENT, "regex\\c\\n", [1, 10],
                    :tSTRING_END,     "/",           [10, 11],
                    :tREGEXP_OPT,     "",            [11, 11]);
}

#[test]
fn test_regexp_escape_chars_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/re\\tge\\nxp/",
                    :tREGEXP_BEG,     "/",            [0, 1],
                    :tSTRING_CONTENT, "re\\tge\\nxp", [1, 11],
                    :tSTRING_END,     "/",            [11, 12],
                    :tREGEXP_OPT,     "",             [12, 12]);
}

#[test]
fn test_regexp_escape_delimiter_meta_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%r(\\))",
                    :tREGEXP_BEG,     "%r(", [0, 3],
                    :tSTRING_CONTENT, "\\)", [3, 5],
                    :tSTRING_END,     ")",   [5, 6],
                    :tREGEXP_OPT,     "",    [6, 6]);
}

#[test]
fn test_regexp_escape_delimiter_nonmeta_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%r'\\''",
                    :tREGEXP_BEG,     "%r'", [0, 3],
                    :tSTRING_CONTENT, "'",   [3, 5],
                    :tSTRING_END,     "'",   [5, 6],
                    :tREGEXP_OPT,     "",    [6, 6]);
}

#[test]
fn test_regexp_escape_double_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/[\\/\\\\]$/",
                    :tREGEXP_BEG,     "/",        [0, 1],
                    :tSTRING_CONTENT, "[/\\\\]$", [1, 8],
                    :tSTRING_END,     "/",        [8, 9],
                    :tREGEXP_OPT,     "",         [9, 9]);
}

#[test]
fn test_regexp_escape_hex_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\x61xp/",
                    :tREGEXP_BEG,     "/",            [0, 1],
                    :tSTRING_CONTENT, "regex\\x61xp", [1, 12],
                    :tSTRING_END,     "/",            [12, 13],
                    :tREGEXP_OPT,     "",             [13, 13]);
}

#[test]
fn test_regexp_escape_hex_one_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/^[\\xd\\xa]{2}/on",
                    :tREGEXP_BEG,     "/",              [0, 1],
                    :tSTRING_CONTENT, "^[\\xd\\xa]{2}", [1, 13],
                    :tSTRING_END,     "/",              [13, 14],
                    :tREGEXP_OPT,     "on",             [14, 16]);
}

#[test]
fn test_regexp_escape_oct1_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\0xp/",
                    :tREGEXP_BEG,     "/",          [0, 1],
                    :tSTRING_CONTENT, "regex\\0xp", [1, 10],
                    :tSTRING_END,     "/",          [10, 11],
                    :tREGEXP_OPT,     "",           [11, 11]);
}

#[test]
fn test_regexp_escape_oct2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\07xp/",
                    :tREGEXP_BEG,     "/",           [0, 1],
                    :tSTRING_CONTENT, "regex\\07xp", [1, 11],
                    :tSTRING_END,     "/",           [11, 12],
                    :tREGEXP_OPT,     "",            [12, 12]);
}

#[test]
fn test_regexp_escape_oct3_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\10142/",
                    :tREGEXP_BEG,     "/",            [0, 1],
                    :tSTRING_CONTENT, "regex\\10142", [1, 12],
                    :tSTRING_END,     "/",            [12, 13],
                    :tREGEXP_OPT,     "",             [13, 13]);
}

#[test]
fn test_regexp_escape_other_meta_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/\\.\\$\\*\\+\\.\\?\\|/",
                    :tREGEXP_BEG,     "/",                     [0, 1],
                    :tSTRING_CONTENT, "\\.\\$\\*\\+\\.\\?\\|", [1, 15],
                    :tSTRING_END,     "/",                     [15, 16],
                    :tREGEXP_OPT,     "",                      [16, 16]);
}

#[test]
fn test_regexp_escape_return_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/regex\\\nregex/",
                    :tREGEXP_BEG,     "/",          [0, 1],
                    :tSTRING_CONTENT, "regexregex", [1, 13],
                    :tSTRING_END,     "/",          [13, 14],
                    :tREGEXP_OPT,     "",           [14, 14]);
}

#[test]
fn test_regexp_nm_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "/.*/nm",
                    :tREGEXP_BEG,     "/",  [0, 1],
                    :tSTRING_CONTENT, ".*", [1, 3],
                    :tSTRING_END,     "/",  [3, 4],
                    :tREGEXP_OPT,     "nm", [4, 6]);
}

#[test]
fn test_rparen_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ")",
                    :tRPAREN, ")", [0, 1]);
}

#[test]
fn test_rshft_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a >> 2",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tRSHFT,      ">>", [2, 4],
                    :tINTEGER,    "2",  [5, 6]);
}

#[test]
fn test_rshft_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a >>= 2",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tOP_ASGN,    ">>", [2, 5],
                    :tINTEGER,    "2",  [6, 7]);
}

#[test]
fn test_sclass_label_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "class << a:b",
                    :kCLASS,      "class", [0, 5],
                    :tLSHFT,      "<<",    [6, 8],
                    :tIDENTIFIER, "a",     [9, 10],
                    :tSYMBOL,     "b",     [10, 12]);
}

#[test]
fn test_star_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a * ",
                    :tIDENTIFIER, "a", [0, 1],
                    :tSTAR2,      "*", [2, 3]);
}

#[test]
fn test_star2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a ** ",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tPOW,        "**", [2, 4]);
}

#[test]
fn test_star2_beg_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "** ",
                    :tDSTAR, "**", [0, 2]);
}

#[test]
fn test_star2_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a **= ",
                    :tIDENTIFIER, "a",  [0, 1],
                    :tOP_ASGN,    "**", [2, 5]);
}

#[test]
fn test_star_arg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " *a",
                    :tSTAR,       "*", [1, 2],
                    :tIDENTIFIER, "a", [2, 3]);
}

#[test]
fn test_star_arg_beg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "*a",
                    :tSTAR,       "*", [0, 1],
                    :tIDENTIFIER, "a", [1, 2]);
}

#[test]
fn test_star_arg_beg_fname_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "*a",
                    :tSTAR2,      "*", [0, 1],
                    :tIDENTIFIER, "a", [1, 2]);
}

#[test]
fn test_star_equals_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "a *= ",
                    :tIDENTIFIER, "a", [0, 1],
                    :tOP_ASGN,    "*", [2, 4]);
}

// skipping test_static_env_case_0

#[test]
fn test_string_double_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"string\"",
                    :tSTRING, "string", [0, 8]);
}

#[test]
fn test_string_double_escape_c_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\C-a\"",
                    :tSTRING, "\u{0001}", [0, 6]);
}

#[test]
fn test_string_double_escape_c_upper_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\C-\\\\\"",
                    :tSTRING, "\u{001C}", [0, 7]);
}

// skipping test_string_double_escape_c_upper_escape_case_0

#[test]
fn test_string_double_escape_c_upper_question_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\C-?\"",
                    :tSTRING, "\u{007F}", [0, 6]);
}

// skipping test_string_double_escape_m_upper_case_0

// skipping test_string_double_escape_m_upper_backslash_case_0

// skipping test_string_double_escape_m_upper_escape_case_0

#[test]
fn test_string_double_escape_bs1_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"a\\x07\\x07\"",
                    :tSTRING, "a\x07\x07", [0, 7]);
}

#[test]
fn test_string_double_escape_bs2_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"a\\\\x07\"",
                    :tSTRING, "a\\x07", [0, 6]);
}

#[test]
fn test_string_double_escape_c_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\ca\"",
                    :tSTRING, "\u{0001}", [0, 5]);
}

// skipping test_string_double_escape_c_escape_case_0

#[test]
fn test_string_double_escape_c_question_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\c?\"",
                    :tSTRING, "\u{007F}", [0, 5]);
}

#[test]
fn test_string_double_escape_chars_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"s\\tri\\ng\"",
                    :tSTRING, "s\tri\ng", [0, 10]);
}

#[test]
fn test_string_double_escape_hex_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"n = \\x61\\x62\\x63\"",
                    :tSTRING, "n = abc", [0, 18]);
}

#[test]
fn test_string_double_escape_octal_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"n = \\101\\102\\103\"",
                    :tSTRING, "n = ABC", [0, 18]);
}

// skipping test_string_double_escape_octal_wrap_case_0

#[test]
fn test_string_double_nested_curlies_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%{nest{one{two}one}nest}",
                    :tSTRING_BEG,     "%{",                    [0, 2],
                    :tSTRING_CONTENT, "nest{one{two}one}nest", [2, 23],
                    :tSTRING_END,     "}",                     [23, 24]);
}

#[test]
fn test_string_double_no_interp_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"# blah\"",
                    :tSTRING, "# blah", [0, 8]);
}

#[test]
fn test_string_double_no_interp_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"blah # blah\"",
                    :tSTRING, "blah # blah", [0, 13]);
}

#[test]
fn test_string_escape_x_single_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"\\x0\"",
                    :tSTRING, "\u{0000}", [0, 5]);
}

#[test]
fn test_string_pct_i_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%I(s1 s2)",
                    :tSYMBOLS_BEG,    "%I(", [0, 3],
                    :tSTRING_CONTENT, "s1",  [3, 5],
                    :tSPACE,          "",    [5, 6],
                    :tSTRING_CONTENT, "s2",  [6, 8],
                    :tSPACE,          "",    [8, 8],
                    :tSTRING_END,     ")",   [8, 9]);
}

#[test]
fn test_string_pct_q_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%Q[s1 s2]",
                    :tSTRING_BEG,     "%Q[",   [0, 3],
                    :tSTRING_CONTENT, "s1 s2", [3, 8],
                    :tSTRING_END,     "]",     [8, 9]);
}

#[test]
fn test_string_pct_q_upper_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%Q\\x07\\",
                    :tSTRING_BEG,     "%Q\\", [0, 3],
                    :tSTRING_CONTENT, "a",    [3, 4],
                    :tSTRING_END,     "\\",   [4, 5]);
}

#[test]
fn test_string_pct_w_upper_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%W[s1 s2\ns3]",
                    :tWORDS_BEG,      "%W[", [0, 3],
                    :tSTRING_CONTENT, "s1",  [3, 5],
                    :tSPACE,          "",    [5, 6],
                    :tSTRING_CONTENT, "s2",  [6, 8],
                    :tSPACE,          "",    [8, 9],
                    :tSTRING_CONTENT, "s3",  [9, 11],
                    :tSPACE,          "",    [11, 11],
                    :tSTRING_END,     "]",   [11, 12]);
}

#[test]
fn test_string_pct_w_upper_bs_nl_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%W[s1 \\\ns2]",
                    :tWORDS_BEG,      "%W[",  [0, 3],
                    :tSTRING_CONTENT, "s1",   [3, 5],
                    :tSPACE,          "",     [5, 6],
                    :tSTRING_CONTENT, "\ns2", [6, 10],
                    :tSPACE,          "",     [10, 10],
                    :tSTRING_END,     "]",    [10, 11]);
}

#[test]
fn test_string_pct_angle_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%<blah>",
                    :tSTRING_BEG,     "%<",   [0, 2],
                    :tSTRING_CONTENT, "blah", [2, 6],
                    :tSTRING_END,     ">",    [6, 7]);
}

#[test]
fn test_string_pct_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%\\x07\\",
                    :tSTRING_BEG,     "%\\", [0, 2],
                    :tSTRING_CONTENT, "a",   [2, 3],
                    :tSTRING_END,     "\\",  [3, 4]);
}

#[test]
fn test_string_pct_i_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%i(s1 s2)",
                    :tQSYMBOLS_BEG,   "%i(", [0, 3],
                    :tSTRING_CONTENT, "s1",  [3, 5],
                    :tSPACE,          "",    [5, 6],
                    :tSTRING_CONTENT, "s2",  [6, 8],
                    :tSPACE,          "",    [8, 8],
                    :tSTRING_END,     ")",   [8, 9]);
}

#[test]
fn test_string_pct_intertwined_with_heredoc_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<-foo + %\\x07\nbar\nfoo\nb\\",
                    :tSTRING_BEG,     "<<\"",  [0, 6],
                    :tSTRING_CONTENT, "bar\n", [13, 17],
                    :tSTRING_END,     "foo",   [17, 20],
                    :tPLUS,           "+",     [7, 8],
                    :tSTRING_BEG,     "%\\",   [9, 11],
                    :tSTRING_CONTENT, "a\n",   [11, 13],
                    :tSTRING_CONTENT, "b",     [21, 22],
                    :tSTRING_END,     "\\",    [22, 23]);
}

#[test]
fn test_string_pct_pct_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%%blah%",
                    :tSTRING_BEG,     "%%",   [0, 2],
                    :tSTRING_CONTENT, "blah", [2, 6],
                    :tSTRING_END,     "%",    [6, 7]);
}

#[test]
fn test_string_pct_q_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%q\\x07\\",
                    :tSTRING_BEG,     "%q\\", [0, 3],
                    :tSTRING_CONTENT, "a",    [3, 4],
                    :tSTRING_END,     "\\",   [4, 5]);
}

#[test]
fn test_string_pct_w_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%w[s1 s2 ]",
                    :tQWORDS_BEG,     "%w[", [0, 3],
                    :tSTRING_CONTENT, "s1",  [3, 5],
                    :tSPACE,          "",    [5, 6],
                    :tSTRING_CONTENT, "s2",  [6, 8],
                    :tSPACE,          "",    [8, 9],
                    :tSTRING_END,     "]",   [9, 10]);
}

#[test]
fn test_string_pct_w_backslash_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%w\\s1 s2 \\",
                    :tQWORDS_BEG,     "%w\\", [0, 3],
                    :tSTRING_CONTENT, "s1",   [3, 5],
                    :tSPACE,          "",     [5, 6],
                    :tSTRING_CONTENT, "s2",   [6, 8],
                    :tSPACE,          "",     [8, 9],
                    :tSTRING_END,     "\\",   [9, 10]);
}

#[test]
fn test_string_pct_w_backslash_nl_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%w\\s1 s2 \\\n",
                    :tQWORDS_BEG,     "%w\\", [0, 3],
                    :tSTRING_CONTENT, "s1",   [3, 5],
                    :tSPACE,          "",     [5, 6],
                    :tSTRING_CONTENT, "s2",   [6, 8],
                    :tSPACE,          "",     [8, 9],
                    :tSTRING_END,     "\\",   [9, 10],
                    :tNL,             "",     [10, 11]);
}

#[test]
fn test_string_pct_w_bs_nl_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%w[s1 \\\ns2]",
                    :tQWORDS_BEG,     "%w[",  [0, 3],
                    :tSTRING_CONTENT, "s1",   [3, 5],
                    :tSPACE,          "",     [5, 6],
                    :tSTRING_CONTENT, "\ns2", [6, 10],
                    :tSPACE,          "",     [10, 10],
                    :tSTRING_END,     "]",    [10, 11]);
}

#[test]
fn test_string_pct_w_bs_sp_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%w[s\\ 1 s\\ 2]",
                    :tQWORDS_BEG,     "%w[", [0, 3],
                    :tSTRING_CONTENT, "s 1", [3, 7],
                    :tSPACE,          "",    [7, 8],
                    :tSTRING_CONTENT, "s 2", [8, 12],
                    :tSPACE,          "",    [12, 12],
                    :tSTRING_END,     "]",   [12, 13]);
}

#[test]
fn test_string_pct_w_tab_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "%w[abc\tdef]",
                    :tQWORDS_BEG,     "%w[", [0, 3],
                    :tSTRING_CONTENT, "abc", [3, 6],
                    :tSPACE,          "",    [6, 7],
                    :tSTRING_CONTENT, "def", [7, 10],
                    :tSPACE,          "",    [10, 10],
                    :tSTRING_END,     "]",   [10, 11]);
}

#[test]
fn test_string_single_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "'string'",
                    :tSTRING, "string", [0, 8]);
}

#[test]
fn test_string_single_escape_chars_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "'s\\tri\\ng'",
                    :tSTRING, "s\\tri\\ng", [0, 10]);
}

#[test]
fn test_string_single_nl_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "'blah\\\nblah'",
                    :tSTRING_BEG,     "'",        [0, 1],
                    :tSTRING_CONTENT, "blah\\\n", [1, 7],
                    :tSTRING_CONTENT, "blah",     [7, 11],
                    :tSTRING_END,     "'",        [11, 12]);
}

#[test]
fn test_symbol_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":symbol",
                    :tSYMBOL, "symbol", [0, 7]);
}

#[test]
fn test_symbol_double_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":\"symbol\"",
                    :tSYMBEG,         ":\"",    [0, 2],
                    :tSTRING_CONTENT, "symbol", [2, 8],
                    :tSTRING_END,     "\"",     [8, 9]);
}

#[test]
fn test_symbol_single_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    ":'symbol'",
                    :tSYMBEG,         ":'",     [0, 2],
                    :tSTRING_CONTENT, "symbol", [2, 8],
                    :tSTRING_END,     "'",      [8, 9]);
}

#[test]
fn test_tilde_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "~",
                    :tTILDE, "~", [0, 1]);
}

#[test]
fn test_tilde_unary_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "~@",
                    :tTILDE, "~@", [0, 2]);
}

#[test]
fn test_transcoded_source_is_converted_back_to_original_encoding_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "\"a\" + \"b\"",
                    :tSTRING, "a", [0, 3],
                    :tPLUS,   "+", [4, 5],
                    :tSTRING, "b", [6, 9]);
}

#[test]
fn test_uminus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "-blah",
                    :tUMINUS,     "-",    [0, 1],
                    :tIDENTIFIER, "blah", [1, 5]);
}

#[test]
fn test_underscore_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "_var",
                    :tIDENTIFIER, "_var", [0, 4]);
}

#[test]
fn test_underscore_end_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "__END__\n",
                    );
}

#[test]
fn test_underscore_end_case_1() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "__END__",
                    );
}

#[test]
fn test_underscore_end_case_2() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "__END__ foo",
                    :tIDENTIFIER, "__END__", [0, 7],
                    :tIDENTIFIER, "foo",     [8, 11]);
}

#[test]
fn test_underscore_end_case_3() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "__END__\rfoo",
                    :tIDENTIFIER, "__END__", [0, 7],
                    :tIDENTIFIER, "foo",     [8, 11]);
}

#[test]
fn test_uplus_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "+blah",
                    :tUPLUS,      "+",    [0, 1],
                    :tIDENTIFIER, "blah", [1, 5]);
}

#[test]
fn test_whitespace_arg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "+",
                    :tPLUS, "+", [0, 1]);
}

#[test]
fn test_whitespace_arg_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    " +",
                    :tUPLUS, "+", [1, 2]);
}

#[test]
fn test_whitespace_arg_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "\n+",
                    :tNL,    "",  [0, 1],
                    :tUPLUS, "+", [1, 2]);
}

#[test]
fn test_whitespace_arg_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "\\\n+",
                    :tUPLUS, "+", [2, 3]);
}

#[test]
fn test_whitespace_arg_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "\\\n +",
                    :tUPLUS, "+", [3, 4]);
}

#[test]
fn test_whitespace_arg_case_5() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ARG);
    assert_scanned!(&mut lexer,
                    "#foo\n+",
                    :tNL,    "",  [4, 5],
                    :tUPLUS, "+", [5, 6]);
}

#[test]
fn test_whitespace_beg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "+",
                    :tUPLUS, "+", [0, 1]);
}

#[test]
fn test_whitespace_beg_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    " +",
                    :tUPLUS, "+", [1, 2]);
}

#[test]
fn test_whitespace_beg_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "\n+",
                    :tUPLUS, "+", [1, 2]);
}

#[test]
fn test_whitespace_beg_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "\\\n+",
                    :tUPLUS, "+", [2, 3]);
}

#[test]
fn test_whitespace_beg_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_BEG);
    assert_scanned!(&mut lexer,
                    "#foo\n+",
                    :tUPLUS, "+", [5, 6]);
}

#[test]
fn test_whitespace_cr_case_0() {
    let mut lexer = setup_lexer!();
    assert_scanned!(&mut lexer,
                    "<<E\nfoo\nE\rO",
                    :tSTRING_BEG,     "<<\"",  [0, 3],
                    :tSTRING_CONTENT, "foo\n", [4, 8],
                    :tSTRING_END,     "E",     [8, 11],
                    :tNL,             "",      [3, 4]);
}

#[test]
fn test_whitespace_dot_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "class",
                    :tIDENTIFIER, "class", [0, 5]);
}

#[test]
fn test_whitespace_dot_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    " class",
                    :tIDENTIFIER, "class", [1, 6]);
}

#[test]
fn test_whitespace_dot_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "\nclass",
                    :tIDENTIFIER, "class", [1, 6]);
}

#[test]
fn test_whitespace_dot_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "\\\nclass",
                    :tIDENTIFIER, "class", [2, 7]);
}

#[test]
fn test_whitespace_dot_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_DOT);
    assert_scanned!(&mut lexer,
                    "#foo\nclass",
                    :tIDENTIFIER, "class", [5, 10]);
}

#[test]
fn test_whitespace_end_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "+ 1",
                    :tPLUS,    "+", [0, 1],
                    :tINTEGER, "1", [2, 3]);
}

#[test]
fn test_whitespace_end_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    " + 1",
                    :tPLUS,    "+", [1, 2],
                    :tINTEGER, "1", [3, 4]);
}

// skipping test_whitespace_end_case_2

#[test]
fn test_whitespace_end_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "\\\n+ 1",
                    :tPLUS,    "+", [2, 3],
                    :tINTEGER, "1", [4, 5]);
}

#[test]
fn test_whitespace_end_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_END);
    assert_scanned!(&mut lexer,
                    "#foo\n+ 1",
                    :tNL,        "",  [4, 5],
                    :tUNARY_NUM, "+", [5, 6],
                    :tINTEGER,   "1", [7, 8]);
}

#[test]
fn test_whitespace_endarg_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    "{",
                    :tLBRACE_ARG, "{", [0, 1]);
}

#[test]
fn test_whitespace_endarg_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    " {",
                    :tLBRACE_ARG, "{", [1, 2]);
}

#[test]
fn test_whitespace_endarg_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    "\n{",
                    :tNL,     "",  [0, 1],
                    :tLBRACE, "{", [1, 2]);
}

#[test]
fn test_whitespace_endarg_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    "\\\n{",
                    :tLBRACE_ARG, "{", [2, 3]);
}

#[test]
fn test_whitespace_endarg_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDARG);
    assert_scanned!(&mut lexer,
                    "#foo\n{",
                    :tNL,     "",  [4, 5],
                    :tLBRACE, "{", [5, 6]);
}

#[test]
fn test_whitespace_endfn_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    "foo:",
                    :tLABEL, "foo", [0, 4]);
}

#[test]
fn test_whitespace_endfn_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    " foo:",
                    :tLABEL, "foo", [1, 5]);
}

#[test]
fn test_whitespace_endfn_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    "\nfoo:",
                    :tNL,         "",    [0, 1],
                    :tIDENTIFIER, "foo", [1, 4],
                    :tCOLON,      ":",   [4, 5]);
}

#[test]
fn test_whitespace_endfn_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    "\nfoo: ",
                    :tNL,         "",    [0, 1],
                    :tIDENTIFIER, "foo", [1, 4],
                    :tCOLON,      ":",   [4, 5]);
}

#[test]
fn test_whitespace_endfn_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    "\\\nfoo:",
                    :tLABEL, "foo", [2, 6]);
}

#[test]
fn test_whitespace_endfn_case_5() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    "#foo\nfoo:",
                    :tNL,         "",    [4, 5],
                    :tIDENTIFIER, "foo", [5, 8],
                    :tCOLON,      ":",   [8, 9]);
}

#[test]
fn test_whitespace_endfn_case_6() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_ENDFN);
    assert_scanned!(&mut lexer,
                    "#foo\nfoo: ",
                    :tNL,         "",    [4, 5],
                    :tIDENTIFIER, "foo", [5, 8],
                    :tCOLON,      ":",   [8, 9]);
}

#[test]
fn test_whitespace_fname_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "class",
                    :kCLASS, "class", [0, 5]);
}

#[test]
fn test_whitespace_fname_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    " class",
                    :kCLASS, "class", [1, 6]);
}

#[test]
fn test_whitespace_fname_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "\nclass",
                    :kCLASS, "class", [1, 6]);
}

#[test]
fn test_whitespace_fname_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "\\\nclass",
                    :kCLASS, "class", [2, 7]);
}

#[test]
fn test_whitespace_fname_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_FNAME);
    assert_scanned!(&mut lexer,
                    "#foo\nclass",
                    :kCLASS, "class", [5, 10]);
}

#[test]
fn test_whitespace_mid_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_MID);
    assert_scanned!(&mut lexer,
                    "+",
                    :tUPLUS, "+", [0, 1]);
}

#[test]
fn test_whitespace_mid_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_MID);
    assert_scanned!(&mut lexer,
                    " +",
                    :tUPLUS, "+", [1, 2]);
}

#[test]
fn test_whitespace_mid_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_MID);
    assert_scanned!(&mut lexer,
                    "\n+",
                    :tNL,    "",  [0, 1],
                    :tUPLUS, "+", [1, 2]);
}

#[test]
fn test_whitespace_mid_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_MID);
    assert_scanned!(&mut lexer,
                    "\\\n+",
                    :tUPLUS, "+", [2, 3]);
}

#[test]
fn test_whitespace_mid_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_MID);
    assert_scanned!(&mut lexer,
                    "#foo\n+",
                    :tNL,    "",  [4, 5],
                    :tUPLUS, "+", [5, 6]);
}

#[test]
fn test_whitespace_value_case_0() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_VALUE);
    assert_scanned!(&mut lexer,
                    "a:b",
                    :tIDENTIFIER, "a", [0, 1],
                    :tSYMBOL,     "b", [1, 3]);
}

#[test]
fn test_whitespace_value_case_1() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_VALUE);
    assert_scanned!(&mut lexer,
                    " a:b",
                    :tIDENTIFIER, "a", [1, 2],
                    :tSYMBOL,     "b", [2, 4]);
}

#[test]
fn test_whitespace_value_case_2() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_VALUE);
    assert_scanned!(&mut lexer,
                    "\na:b",
                    :tIDENTIFIER, "a", [1, 2],
                    :tSYMBOL,     "b", [2, 4]);
}

#[test]
fn test_whitespace_value_case_3() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_VALUE);
    assert_scanned!(&mut lexer,
                    "\\\na:b",
                    :tIDENTIFIER, "a", [2, 3],
                    :tSYMBOL,     "b", [3, 5]);
}

#[test]
fn test_whitespace_value_case_4() {
    let mut lexer = setup_lexer!();
    set_lex_state!(lexer, EXPR_VALUE);
    assert_scanned!(&mut lexer,
                    "#foo\na:b",
                    :tIDENTIFIER, "a", [5, 6],
                    :tSYMBOL,     "b", [6, 8]);
}
