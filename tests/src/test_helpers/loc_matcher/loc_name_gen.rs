// This file is autogenerated by codegen/loc_name.liquid

use super::LocName;
use lib_ruby_parser::{Node, Loc};
use lib_ruby_parser::nodes::*;

impl LocName {
    fn get_begin_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Args(Args { begin_l: loc, .. }) =>*loc,
            Node::Array(Array { begin_l: loc, .. }) =>*loc,
            Node::ArrayPattern(ArrayPattern { begin_l: loc, .. }) =>*loc,
            Node::ArrayPatternWithTail(ArrayPatternWithTail { begin_l: loc, .. }) =>*loc,
            Node::Begin(Begin { begin_l: loc, .. }) =>*loc,
            Node::Block(Block { begin_l: loc, .. }) =>Some(*loc),
            Node::ConstPattern(ConstPattern { begin_l: loc, .. }) =>Some(*loc),
            Node::CSend(CSend { begin_l: loc, .. }) =>*loc,
            Node::Defined(Defined { begin_l: loc, .. }) =>*loc,
            Node::Dstr(Dstr { begin_l: loc, .. }) =>*loc,
            Node::Dsym(Dsym { begin_l: loc, .. }) =>*loc,
            Node::FindPattern(FindPattern { begin_l: loc, .. }) =>*loc,
            Node::For(For { begin_l: loc, .. }) =>Some(*loc),
            Node::Hash(Hash { begin_l: loc, .. }) =>*loc,
            Node::HashPattern(HashPattern { begin_l: loc, .. }) =>*loc,
            Node::If(If { begin_l: loc, .. }) =>Some(*loc),
            Node::Index(Index { begin_l: loc, .. }) =>Some(*loc),
            Node::IndexAsgn(IndexAsgn { begin_l: loc, .. }) =>Some(*loc),
            Node::InPattern(InPattern { begin_l: loc, .. }) =>Some(*loc),
            Node::KwBegin(KwBegin { begin_l: loc, .. }) =>*loc,
            Node::Mlhs(Mlhs { begin_l: loc, .. }) =>*loc,
            Node::Numblock(Numblock { begin_l: loc, .. }) =>Some(*loc),
            Node::Postexe(Postexe { begin_l: loc, .. }) =>Some(*loc),
            Node::Preexe(Preexe { begin_l: loc, .. }) =>Some(*loc),
            Node::Procarg0(Procarg0 { begin_l: loc, .. }) =>*loc,
            Node::Regexp(Regexp { begin_l: loc, .. }) =>Some(*loc),
            Node::RescueBody(RescueBody { begin_l: loc, .. }) =>*loc,
            Node::Send(Send { begin_l: loc, .. }) =>*loc,
            Node::Str(Str { begin_l: loc, .. }) =>*loc,
            Node::Super(Super { begin_l: loc, .. }) =>*loc,
            Node::Sym(Sym { begin_l: loc, .. }) =>*loc,
            Node::Until(Until { begin_l: loc, .. }) =>*loc,
            Node::When(When { begin_l: loc, .. }) =>Some(*loc),
            Node::While(While { begin_l: loc, .. }) =>*loc,
            Node::Xstr(Xstr { begin_l: loc, .. }) =>Some(*loc),
            Node::Yield(Yield { begin_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support begin_l loc", node.str_type())
            }
        }
    }
    fn get_end_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Args(Args { end_l: loc, .. }) =>*loc,
            Node::Array(Array { end_l: loc, .. }) =>*loc,
            Node::ArrayPattern(ArrayPattern { end_l: loc, .. }) =>*loc,
            Node::ArrayPatternWithTail(ArrayPatternWithTail { end_l: loc, .. }) =>*loc,
            Node::Begin(Begin { end_l: loc, .. }) =>*loc,
            Node::Block(Block { end_l: loc, .. }) =>Some(*loc),
            Node::Case(Case { end_l: loc, .. }) =>Some(*loc),
            Node::CaseMatch(CaseMatch { end_l: loc, .. }) =>Some(*loc),
            Node::Class(Class { end_l: loc, .. }) =>Some(*loc),
            Node::ConstPattern(ConstPattern { end_l: loc, .. }) =>Some(*loc),
            Node::CSend(CSend { end_l: loc, .. }) =>*loc,
            Node::Def(Def { end_l: loc, .. }) =>*loc,
            Node::Defined(Defined { end_l: loc, .. }) =>*loc,
            Node::Defs(Defs { end_l: loc, .. }) =>*loc,
            Node::Dstr(Dstr { end_l: loc, .. }) =>*loc,
            Node::Dsym(Dsym { end_l: loc, .. }) =>*loc,
            Node::FindPattern(FindPattern { end_l: loc, .. }) =>*loc,
            Node::For(For { end_l: loc, .. }) =>Some(*loc),
            Node::Hash(Hash { end_l: loc, .. }) =>*loc,
            Node::HashPattern(HashPattern { end_l: loc, .. }) =>*loc,
            Node::If(If { end_l: loc, .. }) =>*loc,
            Node::Index(Index { end_l: loc, .. }) =>Some(*loc),
            Node::IndexAsgn(IndexAsgn { end_l: loc, .. }) =>Some(*loc),
            Node::KwBegin(KwBegin { end_l: loc, .. }) =>*loc,
            Node::Mlhs(Mlhs { end_l: loc, .. }) =>*loc,
            Node::Module(Module { end_l: loc, .. }) =>Some(*loc),
            Node::Numblock(Numblock { end_l: loc, .. }) =>Some(*loc),
            Node::Postexe(Postexe { end_l: loc, .. }) =>Some(*loc),
            Node::Preexe(Preexe { end_l: loc, .. }) =>Some(*loc),
            Node::Procarg0(Procarg0 { end_l: loc, .. }) =>*loc,
            Node::Regexp(Regexp { end_l: loc, .. }) =>Some(*loc),
            Node::SClass(SClass { end_l: loc, .. }) =>Some(*loc),
            Node::Send(Send { end_l: loc, .. }) =>*loc,
            Node::Str(Str { end_l: loc, .. }) =>*loc,
            Node::Super(Super { end_l: loc, .. }) =>*loc,
            Node::Sym(Sym { end_l: loc, .. }) =>*loc,
            Node::Until(Until { end_l: loc, .. }) =>*loc,
            Node::While(While { end_l: loc, .. }) =>*loc,
            Node::Xstr(Xstr { end_l: loc, .. }) =>Some(*loc),
            Node::Yield(Yield { end_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support end_l loc", node.str_type())
            }
        }
    }
    fn get_expression_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Alias(Alias { expression_l: loc, .. }) =>Some(*loc),
            Node::And(And { expression_l: loc, .. }) =>Some(*loc),
            Node::AndAsgn(AndAsgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Arg(Arg { expression_l: loc, .. }) =>Some(*loc),
            Node::Args(Args { expression_l: loc, .. }) =>Some(*loc),
            Node::Array(Array { expression_l: loc, .. }) =>Some(*loc),
            Node::ArrayPattern(ArrayPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::ArrayPatternWithTail(ArrayPatternWithTail { expression_l: loc, .. }) =>Some(*loc),
            Node::BackRef(BackRef { expression_l: loc, .. }) =>Some(*loc),
            Node::Begin(Begin { expression_l: loc, .. }) =>Some(*loc),
            Node::Block(Block { expression_l: loc, .. }) =>Some(*loc),
            Node::Blockarg(Blockarg { expression_l: loc, .. }) =>Some(*loc),
            Node::BlockPass(BlockPass { expression_l: loc, .. }) =>Some(*loc),
            Node::Break(Break { expression_l: loc, .. }) =>Some(*loc),
            Node::Case(Case { expression_l: loc, .. }) =>Some(*loc),
            Node::CaseMatch(CaseMatch { expression_l: loc, .. }) =>Some(*loc),
            Node::Casgn(Casgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Cbase(Cbase { expression_l: loc, .. }) =>Some(*loc),
            Node::Class(Class { expression_l: loc, .. }) =>Some(*loc),
            Node::Complex(Complex { expression_l: loc, .. }) =>Some(*loc),
            Node::Const(Const { expression_l: loc, .. }) =>Some(*loc),
            Node::ConstPattern(ConstPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::CSend(CSend { expression_l: loc, .. }) =>Some(*loc),
            Node::Cvar(Cvar { expression_l: loc, .. }) =>Some(*loc),
            Node::Cvasgn(Cvasgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Def(Def { expression_l: loc, .. }) =>Some(*loc),
            Node::Defined(Defined { expression_l: loc, .. }) =>Some(*loc),
            Node::Defs(Defs { expression_l: loc, .. }) =>Some(*loc),
            Node::Dstr(Dstr { expression_l: loc, .. }) =>Some(*loc),
            Node::Dsym(Dsym { expression_l: loc, .. }) =>Some(*loc),
            Node::EFlipFlop(EFlipFlop { expression_l: loc, .. }) =>Some(*loc),
            Node::EmptyElse(EmptyElse { expression_l: loc, .. }) =>Some(*loc),
            Node::Encoding(Encoding { expression_l: loc, .. }) =>Some(*loc),
            Node::Ensure(Ensure { expression_l: loc, .. }) =>Some(*loc),
            Node::Erange(Erange { expression_l: loc, .. }) =>Some(*loc),
            Node::False(False { expression_l: loc, .. }) =>Some(*loc),
            Node::File(File { expression_l: loc, .. }) =>Some(*loc),
            Node::FindPattern(FindPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::Float(Float { expression_l: loc, .. }) =>Some(*loc),
            Node::For(For { expression_l: loc, .. }) =>Some(*loc),
            Node::ForwardArg(ForwardArg { expression_l: loc, .. }) =>Some(*loc),
            Node::ForwardedArgs(ForwardedArgs { expression_l: loc, .. }) =>Some(*loc),
            Node::Gvar(Gvar { expression_l: loc, .. }) =>Some(*loc),
            Node::Gvasgn(Gvasgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Hash(Hash { expression_l: loc, .. }) =>Some(*loc),
            Node::HashPattern(HashPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::Heredoc(Heredoc { expression_l: loc, .. }) =>Some(*loc),
            Node::If(If { expression_l: loc, .. }) =>Some(*loc),
            Node::IfGuard(IfGuard { expression_l: loc, .. }) =>Some(*loc),
            Node::IFlipFlop(IFlipFlop { expression_l: loc, .. }) =>Some(*loc),
            Node::IfMod(IfMod { expression_l: loc, .. }) =>Some(*loc),
            Node::IfTernary(IfTernary { expression_l: loc, .. }) =>Some(*loc),
            Node::Index(Index { expression_l: loc, .. }) =>Some(*loc),
            Node::IndexAsgn(IndexAsgn { expression_l: loc, .. }) =>Some(*loc),
            Node::InPattern(InPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::Int(Int { expression_l: loc, .. }) =>Some(*loc),
            Node::Irange(Irange { expression_l: loc, .. }) =>Some(*loc),
            Node::Ivar(Ivar { expression_l: loc, .. }) =>Some(*loc),
            Node::Ivasgn(Ivasgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Kwarg(Kwarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Kwargs(Kwargs { expression_l: loc, .. }) =>Some(*loc),
            Node::KwBegin(KwBegin { expression_l: loc, .. }) =>Some(*loc),
            Node::Kwnilarg(Kwnilarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Kwoptarg(Kwoptarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Kwrestarg(Kwrestarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Kwsplat(Kwsplat { expression_l: loc, .. }) =>Some(*loc),
            Node::Lambda(Lambda { expression_l: loc, .. }) =>Some(*loc),
            Node::Line(Line { expression_l: loc, .. }) =>Some(*loc),
            Node::Lvar(Lvar { expression_l: loc, .. }) =>Some(*loc),
            Node::Lvasgn(Lvasgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Masgn(Masgn { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchAlt(MatchAlt { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchAs(MatchAs { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchCurrentLine(MatchCurrentLine { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchNilPattern(MatchNilPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchPattern(MatchPattern { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchPatternP(MatchPatternP { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchRest(MatchRest { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchVar(MatchVar { expression_l: loc, .. }) =>Some(*loc),
            Node::MatchWithLvasgn(MatchWithLvasgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Mlhs(Mlhs { expression_l: loc, .. }) =>Some(*loc),
            Node::Module(Module { expression_l: loc, .. }) =>Some(*loc),
            Node::Next(Next { expression_l: loc, .. }) =>Some(*loc),
            Node::Nil(Nil { expression_l: loc, .. }) =>Some(*loc),
            Node::NthRef(NthRef { expression_l: loc, .. }) =>Some(*loc),
            Node::Numblock(Numblock { expression_l: loc, .. }) =>Some(*loc),
            Node::OpAsgn(OpAsgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Optarg(Optarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Or(Or { expression_l: loc, .. }) =>Some(*loc),
            Node::OrAsgn(OrAsgn { expression_l: loc, .. }) =>Some(*loc),
            Node::Pair(Pair { expression_l: loc, .. }) =>Some(*loc),
            Node::Pin(Pin { expression_l: loc, .. }) =>Some(*loc),
            Node::Postexe(Postexe { expression_l: loc, .. }) =>Some(*loc),
            Node::Preexe(Preexe { expression_l: loc, .. }) =>Some(*loc),
            Node::Procarg0(Procarg0 { expression_l: loc, .. }) =>Some(*loc),
            Node::Rational(Rational { expression_l: loc, .. }) =>Some(*loc),
            Node::Redo(Redo { expression_l: loc, .. }) =>Some(*loc),
            Node::Regexp(Regexp { expression_l: loc, .. }) =>Some(*loc),
            Node::RegOpt(RegOpt { expression_l: loc, .. }) =>Some(*loc),
            Node::Rescue(Rescue { expression_l: loc, .. }) =>Some(*loc),
            Node::RescueBody(RescueBody { expression_l: loc, .. }) =>Some(*loc),
            Node::Restarg(Restarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Retry(Retry { expression_l: loc, .. }) =>Some(*loc),
            Node::Return(Return { expression_l: loc, .. }) =>Some(*loc),
            Node::SClass(SClass { expression_l: loc, .. }) =>Some(*loc),
            Node::Self_(Self_ { expression_l: loc, .. }) =>Some(*loc),
            Node::Send(Send { expression_l: loc, .. }) =>Some(*loc),
            Node::Shadowarg(Shadowarg { expression_l: loc, .. }) =>Some(*loc),
            Node::Splat(Splat { expression_l: loc, .. }) =>Some(*loc),
            Node::Str(Str { expression_l: loc, .. }) =>Some(*loc),
            Node::Super(Super { expression_l: loc, .. }) =>Some(*loc),
            Node::Sym(Sym { expression_l: loc, .. }) =>Some(*loc),
            Node::True(True { expression_l: loc, .. }) =>Some(*loc),
            Node::Undef(Undef { expression_l: loc, .. }) =>Some(*loc),
            Node::UnlessGuard(UnlessGuard { expression_l: loc, .. }) =>Some(*loc),
            Node::Until(Until { expression_l: loc, .. }) =>Some(*loc),
            Node::UntilPost(UntilPost { expression_l: loc, .. }) =>Some(*loc),
            Node::When(When { expression_l: loc, .. }) =>Some(*loc),
            Node::While(While { expression_l: loc, .. }) =>Some(*loc),
            Node::WhilePost(WhilePost { expression_l: loc, .. }) =>Some(*loc),
            Node::XHeredoc(XHeredoc { expression_l: loc, .. }) =>Some(*loc),
            Node::Xstr(Xstr { expression_l: loc, .. }) =>Some(*loc),
            Node::Yield(Yield { expression_l: loc, .. }) =>Some(*loc),
            Node::ZSuper(ZSuper { expression_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support expression_l loc", node.str_type())
            }
        }
    }
    fn get_keyword_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Alias(Alias { keyword_l: loc, .. }) =>Some(*loc),
            Node::Break(Break { keyword_l: loc, .. }) =>Some(*loc),
            Node::Case(Case { keyword_l: loc, .. }) =>Some(*loc),
            Node::CaseMatch(CaseMatch { keyword_l: loc, .. }) =>Some(*loc),
            Node::Class(Class { keyword_l: loc, .. }) =>Some(*loc),
            Node::Def(Def { keyword_l: loc, .. }) =>Some(*loc),
            Node::Defined(Defined { keyword_l: loc, .. }) =>Some(*loc),
            Node::Defs(Defs { keyword_l: loc, .. }) =>Some(*loc),
            Node::Ensure(Ensure { keyword_l: loc, .. }) =>Some(*loc),
            Node::For(For { keyword_l: loc, .. }) =>Some(*loc),
            Node::If(If { keyword_l: loc, .. }) =>Some(*loc),
            Node::IfGuard(IfGuard { keyword_l: loc, .. }) =>Some(*loc),
            Node::IfMod(IfMod { keyword_l: loc, .. }) =>Some(*loc),
            Node::InPattern(InPattern { keyword_l: loc, .. }) =>Some(*loc),
            Node::Module(Module { keyword_l: loc, .. }) =>Some(*loc),
            Node::Next(Next { keyword_l: loc, .. }) =>Some(*loc),
            Node::Postexe(Postexe { keyword_l: loc, .. }) =>Some(*loc),
            Node::Preexe(Preexe { keyword_l: loc, .. }) =>Some(*loc),
            Node::RescueBody(RescueBody { keyword_l: loc, .. }) =>Some(*loc),
            Node::Return(Return { keyword_l: loc, .. }) =>Some(*loc),
            Node::SClass(SClass { keyword_l: loc, .. }) =>Some(*loc),
            Node::Super(Super { keyword_l: loc, .. }) =>Some(*loc),
            Node::Undef(Undef { keyword_l: loc, .. }) =>Some(*loc),
            Node::UnlessGuard(UnlessGuard { keyword_l: loc, .. }) =>Some(*loc),
            Node::Until(Until { keyword_l: loc, .. }) =>Some(*loc),
            Node::UntilPost(UntilPost { keyword_l: loc, .. }) =>Some(*loc),
            Node::When(When { keyword_l: loc, .. }) =>Some(*loc),
            Node::While(While { keyword_l: loc, .. }) =>Some(*loc),
            Node::WhilePost(WhilePost { keyword_l: loc, .. }) =>Some(*loc),
            Node::Yield(Yield { keyword_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support keyword_l loc", node.str_type())
            }
        }
    }
    fn get_name_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Blockarg(Blockarg { name_l: loc, .. }) =>*loc,
            Node::Casgn(Casgn { name_l: loc, .. }) =>Some(*loc),
            Node::Const(Const { name_l: loc, .. }) =>Some(*loc),
            Node::Cvasgn(Cvasgn { name_l: loc, .. }) =>Some(*loc),
            Node::Def(Def { name_l: loc, .. }) =>Some(*loc),
            Node::Defs(Defs { name_l: loc, .. }) =>Some(*loc),
            Node::Gvasgn(Gvasgn { name_l: loc, .. }) =>Some(*loc),
            Node::Ivasgn(Ivasgn { name_l: loc, .. }) =>Some(*loc),
            Node::Kwarg(Kwarg { name_l: loc, .. }) =>Some(*loc),
            Node::Kwnilarg(Kwnilarg { name_l: loc, .. }) =>Some(*loc),
            Node::Kwoptarg(Kwoptarg { name_l: loc, .. }) =>Some(*loc),
            Node::Kwrestarg(Kwrestarg { name_l: loc, .. }) =>*loc,
            Node::Lvasgn(Lvasgn { name_l: loc, .. }) =>Some(*loc),
            Node::MatchNilPattern(MatchNilPattern { name_l: loc, .. }) =>Some(*loc),
            Node::MatchVar(MatchVar { name_l: loc, .. }) =>Some(*loc),
            Node::Optarg(Optarg { name_l: loc, .. }) =>Some(*loc),
            Node::Restarg(Restarg { name_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support name_l loc", node.str_type())
            }
        }
    }
    fn get_assignment_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Def(Def { assignment_l: loc, .. }) =>*loc,
            Node::Defs(Defs { assignment_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support assignment_l loc", node.str_type())
            }
        }
    }
    fn get_colon_l(node: &Node) -> Option<Loc> {
        match node {
            Node::IfTernary(IfTernary { colon_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support colon_l loc", node.str_type())
            }
        }
    }
    fn get_double_colon_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Casgn(Casgn { double_colon_l: loc, .. }) =>*loc,
            Node::Const(Const { double_colon_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support double_colon_l loc", node.str_type())
            }
        }
    }
    fn get_else_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Case(Case { else_l: loc, .. }) =>*loc,
            Node::CaseMatch(CaseMatch { else_l: loc, .. }) =>*loc,
            Node::If(If { else_l: loc, .. }) =>*loc,
            Node::Rescue(Rescue { else_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support else_l loc", node.str_type())
            }
        }
    }
    fn get_heredoc_body_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Heredoc(Heredoc { heredoc_body_l: loc, .. }) =>Some(*loc),
            Node::XHeredoc(XHeredoc { heredoc_body_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support heredoc_body_l loc", node.str_type())
            }
        }
    }
    fn get_operator_l(node: &Node) -> Option<Loc> {
        match node {
            Node::And(And { operator_l: loc, .. }) =>Some(*loc),
            Node::AndAsgn(AndAsgn { operator_l: loc, .. }) =>Some(*loc),
            Node::Blockarg(Blockarg { operator_l: loc, .. }) =>Some(*loc),
            Node::BlockPass(BlockPass { operator_l: loc, .. }) =>Some(*loc),
            Node::Casgn(Casgn { operator_l: loc, .. }) =>*loc,
            Node::Class(Class { operator_l: loc, .. }) =>*loc,
            Node::Complex(Complex { operator_l: loc, .. }) =>*loc,
            Node::CSend(CSend { operator_l: loc, .. }) =>*loc,
            Node::Cvasgn(Cvasgn { operator_l: loc, .. }) =>*loc,
            Node::Defs(Defs { operator_l: loc, .. }) =>Some(*loc),
            Node::EFlipFlop(EFlipFlop { operator_l: loc, .. }) =>Some(*loc),
            Node::Erange(Erange { operator_l: loc, .. }) =>Some(*loc),
            Node::Float(Float { operator_l: loc, .. }) =>*loc,
            Node::For(For { operator_l: loc, .. }) =>Some(*loc),
            Node::Gvasgn(Gvasgn { operator_l: loc, .. }) =>*loc,
            Node::IFlipFlop(IFlipFlop { operator_l: loc, .. }) =>Some(*loc),
            Node::IndexAsgn(IndexAsgn { operator_l: loc, .. }) =>*loc,
            Node::Int(Int { operator_l: loc, .. }) =>*loc,
            Node::Irange(Irange { operator_l: loc, .. }) =>Some(*loc),
            Node::Ivasgn(Ivasgn { operator_l: loc, .. }) =>*loc,
            Node::Kwrestarg(Kwrestarg { operator_l: loc, .. }) =>Some(*loc),
            Node::Kwsplat(Kwsplat { operator_l: loc, .. }) =>Some(*loc),
            Node::Lvasgn(Lvasgn { operator_l: loc, .. }) =>*loc,
            Node::Masgn(Masgn { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchAlt(MatchAlt { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchAs(MatchAs { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchNilPattern(MatchNilPattern { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchPattern(MatchPattern { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchPatternP(MatchPatternP { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchRest(MatchRest { operator_l: loc, .. }) =>Some(*loc),
            Node::MatchWithLvasgn(MatchWithLvasgn { operator_l: loc, .. }) =>Some(*loc),
            Node::OpAsgn(OpAsgn { operator_l: loc, .. }) =>Some(*loc),
            Node::Optarg(Optarg { operator_l: loc, .. }) =>Some(*loc),
            Node::Or(Or { operator_l: loc, .. }) =>Some(*loc),
            Node::OrAsgn(OrAsgn { operator_l: loc, .. }) =>Some(*loc),
            Node::Pair(Pair { operator_l: loc, .. }) =>Some(*loc),
            Node::Rational(Rational { operator_l: loc, .. }) =>*loc,
            Node::Restarg(Restarg { operator_l: loc, .. }) =>Some(*loc),
            Node::SClass(SClass { operator_l: loc, .. }) =>Some(*loc),
            Node::Send(Send { operator_l: loc, .. }) =>*loc,
            Node::Splat(Splat { operator_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support operator_l loc", node.str_type())
            }
        }
    }
    fn get_selector_l(node: &Node) -> Option<Loc> {
        match node {
            Node::CSend(CSend { selector_l: loc, .. }) =>*loc,
            Node::Pin(Pin { selector_l: loc, .. }) =>Some(*loc),
            Node::Send(Send { selector_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support selector_l loc", node.str_type())
            }
        }
    }
    fn get_assoc_l(node: &Node) -> Option<Loc> {
        match node {
            Node::RescueBody(RescueBody { assoc_l: loc, .. }) =>*loc,
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support assoc_l loc", node.str_type())
            }
        }
    }
    fn get_question_l(node: &Node) -> Option<Loc> {
        match node {
            Node::IfTernary(IfTernary { question_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support question_l loc", node.str_type())
            }
        }
    }
    fn get_heredoc_end_l(node: &Node) -> Option<Loc> {
        match node {
            Node::Heredoc(Heredoc { heredoc_end_l: loc, .. }) =>Some(*loc),
            Node::XHeredoc(XHeredoc { heredoc_end_l: loc, .. }) =>Some(*loc),
            #[allow(unreachable_patterns)]
            _ => {
                panic!("node {} doesn't support heredoc_end_l loc", node.str_type())
            }
        }
    }
    

    pub(crate) fn get(&self, node: &Node) -> Option<Loc> {
        match self {
            Self::Begin => Self::get_begin_l(node),
            Self::End => Self::get_end_l(node),
            Self::Expression => Self::get_expression_l(node),
            Self::Keyword => Self::get_keyword_l(node),
            Self::Name => Self::get_name_l(node),
            Self::Assignment => Self::get_assignment_l(node),
            Self::Colon => Self::get_colon_l(node),
            Self::DoubleColon => Self::get_double_colon_l(node),
            Self::Else => Self::get_else_l(node),
            Self::HeredocBody => Self::get_heredoc_body_l(node),
            Self::Operator => Self::get_operator_l(node),
            Self::Selector => Self::get_selector_l(node),
            Self::Assoc => Self::get_assoc_l(node),
            Self::Question => Self::get_question_l(node),
            Self::HeredocEnd => Self::get_heredoc_end_l(node),
            
        }
    }
}
