$: << File.expand_path('./parser/test', __dir__)
$: << File.expand_path('./ast/lib', __dir__)

$LOADED_FEATURES << 'simplecov.rb' << 'parser/lexer.rb' << 'minitest/autorun'
module Parser
  class Lexer
    attr_accessor :comments, :diagnostics, :source_buffer, :state, :static_env
    def initialize(*); end
    def reset(*); end
    def advance; end
    def cond; end
  end
end

module Minitest
  def self.after_run(*); end
  class Test
  end
end

require 'test_lexer'
require 'ostruct'

$lex = []

class BlackHole
  def method_missing(*); self; end
end

class TestLexer
  def initialize(*)
    @lex = BlackHole.new
  end

  def setup_lexer(*); end

  INVALID_CHARS = %w[\\a \a \b \e \f \v]

  def assert_scanned(input, *tokens)
    $current << [input, tokens]
  end

  def assert_escape(*); end
  def assert_raises(*); end
  def refute_escape(*); end

  # these guys are too complex
  def assert_lex_fname(*); end
  def assert_equal(*); end
  def test_comment(*); end
  def test_comment_begin(*); end
  def test_comment_begin_space(*); end
  def test_comment_end_space_and_text(*); end
  def test_comment_eos(*); end
end

test = TestLexer.new
methods = test.methods.grep(/\Atest_/).sort
# methods = [:test_bug_string_non_utf]

methods.each do |mid|
  $current = []

  test.send(mid)

  rust_mid = mid.to_s.gsub(/[A-Z]+/) { |match| match.downcase + "_upper" }
  $current.each_with_index do |(input, tokens), idx|
    $lex << ["#{rust_mid}_case_#{idx}".gsub("__", "_").gsub("__", "_"), [input, tokens]]
  end
end

rustify_string = ->(input) {
  input
    .gsub("\\\#", "#")
    .gsub("\\a", "\\x07")
    .gsub("\\b", "\\x08")
    .gsub("\\e", "\\x1b")
    .gsub("\\f", "\\x0c")
    .gsub("\\v", "\\x0b")
    .gsub(/\\u[0-9a-fA-F]{4}/) { |match| "\\u{" + match[-4..-1] + "}"  }
}

$output = $lex.map do |(mid, (input, tokens))|
  if [
    :test_backtick_cmdarg_case_0,
    :test_bug_expr_beg_backspace_nl_case_0,
    :test_whitespace_arg_case_2,
    :test_whitespace_beg_case_2,
    :test_bug_expr_arg_newline_case_0,
    :test_whitespace_dot_case_2,
    :test_whitespace_end_case_2,
    :test_whitespace_endarg_case_2,
    :test_whitespace_endfn_case_2,
    :test_whitespace_endfn_case_3,
    :test_whitespace_fname_case_2,
    :test_whitespace_mid_case_2,
    :test_whitespace_value_case_2,
  ].include?(mid.to_sym)
    next
  end

  input = input.dup.force_encoding('utf-8')
  next unless input.valid_encoding?
  input = rustify_string[input.inspect]


  tokens = tokens.each_slice(3).to_a.map do |(name, value, range)|
    value = value.dup.force_encoding('utf-8') if value.is_a?(String)
    [name, value, range]
  end

  if tokens.any? { |(name, value, range)| value.is_a?(String) && !value.valid_encoding? }
    next
  end

  tokens = tokens.map do |(name, value, range)|
    name = name.inspect + ', '
    if value
      value = rustify_string[value.to_s.inspect]
      value = "Some(#{value}), "
    else
      value = "None, "
    end
    [name, value, range]
  end

  max_name_length  = tokens.map(&:first).map(&:length).max
  max_value_length = tokens.map { |v| v[1] }.map(&:length).max

  tokens = tokens.map do |(name, value, range)|
    name  = name.ljust(max_name_length, ' ')
    value = value.ljust(max_value_length, ' ')
    "#{name}#{value}#{range.inspect}"
  end


  <<-RUST
#[test]
fn #{mid}() {
    assert_scanned!(#{input},
                    #{tokens.join(",\n                    ")});
}
RUST
end

File.write(
  File.expand_path('../tests/lexer_test.rs', __dir__),
<<-RUST
// THIS FILE IS AUTO-GENERATED BY vendor/codegen.rb

mod assert_scanned;

#{$output.join("\n")}
RUST
)
