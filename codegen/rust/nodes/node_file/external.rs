use crate::codegen::c::helpers as c_helpers;
use crate::codegen::rust::nodes::helpers;

fn contents(node: &lib_ruby_parser_nodes::Node) -> String {
    format!(
        "// This file is autogenerated by {generator}

{imports}

use crate::containers::size::NODE_{upper}_SIZE;
use super::internal::Internal{struct_name};
use crate::containers::helpers::IntoBlob;

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub(crate) struct {struct_name}Blob {{
    blob: [u8; NODE_{upper}_SIZE],
}}

{comment}
#[repr(C)]
pub struct {struct_name} {{
    pub(crate) blob: {struct_name}Blob
}}

impl std::fmt::Debug for {struct_name} {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        {debug_impl}
    }}
}}

impl PartialEq for {struct_name} {{
    fn eq(&self, other: &Self) -> bool {{
        {partial_eq_impl}
    }}
}}

impl {struct_name} {{
    {getters}

    #[allow(dead_code)]
    pub(crate) fn into_internal(self) -> Internal{struct_name} {{
        let internal = unsafe {{ {into_internal_fn_name}(self.blob) }};
        std::mem::forget(self);
        internal
    }}
}}

extern \"C\" {{
    {extern_fns}
}}

impl InnerNode for {struct_name} {{
    fn expression(&self) -> &Loc {{
        self.get_expression_l()
    }}

    fn inspected_children(&self, indent: usize) -> Vec<String> {{
        let mut result = InspectVec::new(indent);
        {inspected_children}
        result.strings()
    }}

    fn str_type(&self) -> &'static str {{
        \"{str_type}\"
    }}

    fn print_with_locs(&self) {{
        println!(\"{{}}\", self.inspect(0));
        {print_with_locs}
    }}
}}

impl Drop for {struct_name} {{
    fn drop(&mut self) {{
        unsafe {{ {extern_drop}(&mut self.blob) }}
    }}
}}
",
        generator = file!(),
        upper = node.upper_name(),
        imports = imports(&node).join("\n"),
        comment = node.render_comment("///", 0),
        struct_name = node.struct_name,
        inspected_children = node.fields.map(&inspect_field).join("\n        "),
        str_type = node.str_type,
        print_with_locs = node.fields.flat_map(&print_with_locs).join("\n        "),
        getters = node
            .fields
            .map(&|field| getter(node, field))
            .join("\n\n    "),
        into_internal_fn_name = c_helpers::nodes::into_internal::name(node),
        extern_fns = extern_fns(&node).join("\n    "),
        // trait impls
        debug_impl = debug_impl(&node),
        partial_eq_impl = partial_eq_impl(&node),
        extern_drop = c_helpers::nodes::drop_variant::name(node)
    )
}

pub(crate) fn codegen(node: &lib_ruby_parser_nodes::Node) {
    let path = format!("src/nodes/types/{}/external.rs", node.filename);
    std::fs::write(&path, contents(node)).unwrap();
}

fn imports(node: &lib_ruby_parser_nodes::Node) -> Vec<&str> {
    let mut imports = vec![];
    imports.push("use crate::nodes::InnerNode;");
    imports.push("use crate::nodes::InspectVec;");
    imports.push("use crate::Loc;");
    imports.push("use crate::loc::LocBlob;");

    let has_field = |field_type: lib_ruby_parser_nodes::NodeFieldType| {
        node.fields.any_field_has_type(field_type)
    };

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Node)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::Nodes)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::RegexOptions)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeNode)
    {
        imports.push("use crate::Node;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::StringValue) {
        imports.push("use crate::Bytes;");
        imports.push("use crate::bytes::BytesBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeNode)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::RegexOptions)
    {
        imports.push("use crate::containers::ExternalMaybePtr as MaybePtr;");
        imports.push("use crate::containers::MaybePtrBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Node) {
        imports.push("use crate::containers::ExternalPtr as Ptr;");
        imports.push("use crate::containers::PtrBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Nodes) {
        imports.push("use crate::containers::ExternalList as List;");
        imports.push("use crate::containers::ListBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeLoc) {
        imports.push("use crate::containers::ExternalMaybeLoc as MaybeLoc;");
        imports.push("use crate::containers::MaybeLocBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Str)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::RawString)
    {
        imports.push("use crate::containers::ExternalStringPtr as StringPtr;");
        imports.push("use crate::containers::StringPtrBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeStr)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::Chars)
    {
        imports.push("use crate::containers::ExternalMaybeStringPtr as MaybeStringPtr;");
        imports.push("use crate::containers::MaybeStringPtrBlob;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::U8) {
        imports.push("type Byte = u8;");
        imports.push("type ByteBlob = u8;");
    }

    imports
}

fn inspect_field(field: &lib_ruby_parser_nodes::NodeField) -> String {
    use lib_ruby_parser_nodes::NodeFieldType;

    let method_name = match field.field_type {
        NodeFieldType::Node => "push_node",
        NodeFieldType::Nodes => "push_nodes",
        NodeFieldType::MaybeNode => {
            if field.always_print {
                "push_maybe_node_or_nil"
            } else {
                "push_maybe_node"
            }
        }
        NodeFieldType::Loc => return format!(""),
        NodeFieldType::MaybeLoc => return format!(""),
        NodeFieldType::Str => "push_str",
        NodeFieldType::MaybeStr => "push_maybe_str",
        NodeFieldType::Chars => "push_chars",
        NodeFieldType::StringValue => "push_string_value",
        NodeFieldType::U8 => "push_u8",
        NodeFieldType::Usize => "push_usize",
        NodeFieldType::RawString => "push_raw_str",
        NodeFieldType::RegexOptions => "push_regex_options",
    };

    format!("result.{}(self.get_{}());", method_name, field.field_name)
}
fn print_with_locs(field: &lib_ruby_parser_nodes::NodeField) -> Vec<String> {
    use lib_ruby_parser_nodes::NodeFieldType;

    match field.field_type {
        NodeFieldType::Node => vec![format!(
            "self.get_{field_name}().inner_ref().print_with_locs();",
            field_name = field.field_name
        )],
        NodeFieldType::Nodes => vec![
            format!(
                "for node in self.get_{field_name}().iter() {{",
                field_name = field.field_name
            ),
            "  node.inner_ref().print_with_locs();".to_string(),
            "}".to_string(),
        ],
        NodeFieldType::MaybeNode | NodeFieldType::RegexOptions => vec![format!(
            "self.get_{field_name}().as_ref().map(|node| node.inner_ref().print_with_locs());",
            field_name = field.field_name
        )],
        NodeFieldType::Loc => vec![format!(
            "self.get_{field_name}().print(\"{printable_field_name}\");",
            field_name = field.field_name,
            printable_field_name = field
                .field_name
                .strip_suffix("_l")
                .expect("expected loc field to end with _l")
        )],
        NodeFieldType::MaybeLoc => vec![format!(
            "self.get_{field_name}().as_ref().map(|loc| loc.print(\"{printable_field_name}\"));",
            field_name = field.field_name,
            printable_field_name = field
                .field_name
                .strip_suffix("_l")
                .expect("expected loc field to end with _l"),
        )],
        NodeFieldType::Str => vec![],
        NodeFieldType::MaybeStr => vec![],
        NodeFieldType::Chars => vec![],
        NodeFieldType::StringValue => vec![],
        NodeFieldType::U8 => vec![],
        NodeFieldType::Usize => vec![],
        NodeFieldType::RawString => vec![],
    }
}

fn getter(node: &lib_ruby_parser_nodes::Node, field: &lib_ruby_parser_nodes::NodeField) -> String {
    let getter = format!("get_{}", field.field_name).replace("__", "_");
    let setter = format!("set_{}", field.field_name).replace("__", "_");

    format!(
        "/// Returns `{field_name}` field
    pub fn {getter}(&self) -> &{field_type} {{
        unsafe {{
            #[allow(trivial_casts)]
            ({extern_getter}(&self.blob) as *const {field_type})
                .as_ref()
                .unwrap()
        }}
    }}

    /// Sets `{field_name}` field
    pub fn {setter}(&mut self, {field_name}: {field_type}) {{
        unsafe {{ {extern_setter}(&mut self.blob, {field_name}.into_blob()) }}
    }}",
        field_name = field.field_name,
        field_type = helpers::field_type(field),
        extern_getter = c_helpers::nodes::getter::name(node, field),
        extern_setter = c_helpers::nodes::setter::name(node, field),
        getter = getter,
        setter = setter,
    )
}

fn extern_fns(node: &lib_ruby_parser_nodes::Node) -> Vec<String> {
    let mut result = vec![];

    // Field getters
    {
        node.fields
            .flat_map(&|field| {
                let getter = format!(
                    "fn {getter_name}(blob: *const {struct_name}Blob) -> *mut {field_blob_type};",
                    getter_name = c_helpers::nodes::getter::name(node, field),
                    struct_name = node.camelcase_name(),
                    field_blob_type = helpers::blob_type(field)
                );

                let setter = format!(
                    "fn {setter_name}(blob: *mut {struct_name}Blob, blob: {field_blob_type});",
                    setter_name = c_helpers::nodes::setter::name(node, field),
                    struct_name = node.camelcase_name(),
                    field_blob_type = helpers::blob_type(field)
                );

                vec![getter, setter]
            })
            .into_iter()
            .for_each(|line| result.push(line));
    }

    // into_internal fn
    {
        let line = format!(
            "fn {fn_name}(blob: {struct_name}Blob) -> Internal{struct_name};",
            fn_name = c_helpers::nodes::into_internal::name(node),
            struct_name = node.camelcase_name()
        );
        result.push(line);
    }

    // drop fn
    {
        let line = format!(
            "fn {fn_name}(blob: *mut {struct_name}Blob);",
            fn_name = c_helpers::nodes::drop_variant::name(node),
            struct_name = node.camelcase_name()
        );
        result.push(line);
    }

    result
}

fn debug_impl(node: &lib_ruby_parser_nodes::Node) -> String {
    let mut stmts = vec![];
    stmts.push(format!(
        "f.debug_struct(\"{struct_name}\")\n",
        struct_name = node.camelcase_name()
    ));
    for field in node.fields.0.iter() {
        stmts.push(format!(
            "            .field(\"{field_name}\", &self.get_{field_name}())\n",
            field_name = field.field_name
        ));
    }
    stmts.push(format!("            .finish()"));
    stmts.join("")
}
fn partial_eq_impl(node: &lib_ruby_parser_nodes::Node) -> String {
    node.fields
        .map(&|field| {
            format!(
                "self.get_{field_name}() == other.get_{field_name}()",
                field_name = field.field_name
            )
        })
        .join("\n            && ")
}
