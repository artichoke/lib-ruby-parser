use crate::codegen::rust::nodes::helpers::{node_field_name, struct_name};

fn contents(node: &lib_ruby_parser_nodes::Node) -> String {
    format!(
        "// This file is autogenerated by {generator}

{imports}

#[repr(C)]
pub(crate) struct Internal{struct_name} {{
    {fields_declaration}
}}
",
        generator = file!(),
        imports = imports(&node).join("\n"),
        struct_name = struct_name(node),
        fields_declaration = node.fields.map(&field_declaration).join("\n    "),
    )
}

pub(crate) fn codegen(node: &lib_ruby_parser_nodes::Node) {
    let dir = super::filename(node);
    let path = format!("src/nodes/types/{}/internal.rs", dir);
    std::fs::write(&path, contents(node)).unwrap();
}

fn imports(node: &lib_ruby_parser_nodes::Node) -> Vec<&str> {
    use lib_ruby_parser_nodes::NodeFieldType;

    let mut imports = vec![];
    imports.push("use crate::Loc;");

    let has_field = |field_type: NodeFieldType| node.fields.any_field_has_type(field_type);

    if has_field(NodeFieldType::Node)
        || has_field(NodeFieldType::Nodes)
        || has_field(NodeFieldType::MaybeNode {
            regexp_options: true,
        })
        || has_field(NodeFieldType::MaybeNode {
            regexp_options: false,
        })
    {
        imports.push("use crate::Node;");
    }

    if has_field(NodeFieldType::StringValue) {
        imports.push("use crate::Bytes;");
    }

    enum ImportType {
        External,
        Native,
    }
    use ImportType::*;

    let mut push_import = |import_type: ImportType, s: &'static str| {
        match import_type {
            External => imports.push("#[cfg(feature = \"compile-with-external-structures\")]"),
            Native => imports.push("#[cfg(not(feature = \"compile-with-external-structures\"))]"),
        };
        imports.push(s);
    };

    if has_field(NodeFieldType::MaybeNode {
        regexp_options: true,
    }) || has_field(NodeFieldType::MaybeNode {
        regexp_options: false,
    }) {
        push_import(External, "use crate::containers::ExternalMaybePtr;");
        push_import(External, "type MaybePtr<T> = ExternalMaybePtr<T>;");
        push_import(Native, "type MaybePtr<T> = Option<Box<T>>;");
    }

    if has_field(NodeFieldType::Node) {
        push_import(External, "use crate::containers::ExternalPtr;");
        push_import(External, "type Ptr<T> = ExternalPtr<T>;");
        push_import(Native, "type Ptr<T> = Box<T>;");
    }

    if has_field(NodeFieldType::Nodes) {
        push_import(External, "use crate::containers::ExternalList;");
        push_import(External, "type List<T> = ExternalList<T>;");
        push_import(Native, "type List<T> = Vec<T>;");
    }

    if has_field(NodeFieldType::MaybeLoc) {
        push_import(External, "use crate::containers::ExternalMaybeLoc;");
        push_import(External, "type MaybeLoc = ExternalMaybeLoc;");
        push_import(Native, "type MaybeLoc = Option<Loc>;");
    }

    if has_field(NodeFieldType::Str { raw: true }) || has_field(NodeFieldType::Str { raw: false }) {
        push_import(External, "use crate::containers::ExternalStringPtr;");
        push_import(External, "type StringPtr = ExternalStringPtr;");
        push_import(Native, "type StringPtr = String;")
    }

    if has_field(NodeFieldType::MaybeStr { chars: true })
        || has_field(NodeFieldType::MaybeStr { chars: false })
    {
        push_import(External, "use crate::containers::ExternalMaybeStringPtr;");
        push_import(External, "type MaybeStringPtr = ExternalMaybeStringPtr;");
        push_import(Native, "type MaybeStringPtr = Option<String>;")
    }

    imports
}

fn field_type(field: &lib_ruby_parser_nodes::NodeField) -> &str {
    use lib_ruby_parser_nodes::NodeFieldType;

    match field.field_type {
        NodeFieldType::Node => "Ptr<Node>",
        NodeFieldType::Nodes => "List<Node>",
        NodeFieldType::MaybeNode { .. } => "MaybePtr<Node>",
        NodeFieldType::Loc => "Loc",
        NodeFieldType::MaybeLoc => "MaybeLoc",
        NodeFieldType::Str { .. } => "StringPtr",
        NodeFieldType::MaybeStr { .. } => "MaybeStringPtr",
        NodeFieldType::StringValue => "Bytes",
        NodeFieldType::U8 => "u8",
    }
}

fn field_declaration(field: &lib_ruby_parser_nodes::NodeField) -> String {
    format!(
        "#[allow(dead_code)]
    pub(crate) {field_name}: {field_type},",
        field_name = node_field_name(field),
        field_type = field_type(field)
    )
}
