fn contents(node: &lib_ruby_parser_nodes::Node) -> String {
    format!(
        "// This file is autogenerated by {generator}

{imports}

pub(crate) struct Internal{struct_name} {{
    {fields_declaration}
}}
",
        generator = file!(),
        imports = imports(&node).join("\n"),
        struct_name = node.struct_name,
        fields_declaration = node.fields.map(&field_declaration).join("\n    "),
    )
}

pub(crate) fn codegen(node: &lib_ruby_parser_nodes::Node) {
    let path = format!("src/nodes/types/{}/internal.rs", node.filename);
    std::fs::write(&path, contents(node)).unwrap();
}

fn imports(node: &lib_ruby_parser_nodes::Node) -> Vec<&str> {
    let mut imports = vec![];
    imports.push("use crate::Loc;");

    let has_field = |field_type: lib_ruby_parser_nodes::NodeFieldType| {
        node.fields.any_field_has_type(field_type)
    };

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Node)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::Nodes)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::RegexOptions)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeNode)
    {
        imports.push("use crate::Node;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::StringValue) {
        imports.push("use crate::StringValue;");
    }

    enum ImportType {
        External,
        Native,
    }
    use ImportType::*;

    let mut push_import = |import_type: ImportType, s: &'static str| {
        match import_type {
            External => imports.push("#[cfg(feature = \"compile-with-external-structures\")]"),
            Native => imports.push("#[cfg(not(feature = \"compile-with-external-structures\"))]"),
        };
        imports.push(s);
    };

    if has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeNode)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::RegexOptions)
    {
        push_import(External, "use crate::containers::ExternalMaybePtr;");
        push_import(External, "type MaybePtr<T> = ExternalMaybePtr<T>;");
        push_import(Native, "type MaybePtr<T> = Option<Box<T>>;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Node) {
        push_import(External, "use crate::containers::ExternalPtr;");
        push_import(External, "type Ptr<T> = ExternalPtr<T>;");
        push_import(Native, "type Ptr<T> = Box<T>;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Nodes) {
        push_import(External, "use crate::containers::ExternalList;");
        push_import(External, "type List<T> = ExternalList<T>;");
        push_import(Native, "type List<T> = Vec<T>;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeLoc) {
        push_import(External, "use crate::containers::ExternalMaybeLoc;");
        push_import(External, "type MaybeLoc = ExternalMaybeLoc;");
        push_import(Native, "type MaybeLoc = Option<Loc>;");
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::Str)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::RawString)
    {
        push_import(External, "use crate::containers::ExternalStringPtr;");
        push_import(External, "type StringPtr = ExternalStringPtr;");
        push_import(Native, "type StringPtr = String;")
    }

    if has_field(lib_ruby_parser_nodes::NodeFieldType::MaybeStr)
        || has_field(lib_ruby_parser_nodes::NodeFieldType::Chars)
    {
        push_import(External, "use crate::containers::ExternalMaybeStringPtr;");
        push_import(External, "type MaybeStringPtr = ExternalMaybeStringPtr;");
        push_import(Native, "type MaybeStringPtr = Option<String>;")
    }

    imports
}

fn field_type(field: &lib_ruby_parser_nodes::NodeField) -> &str {
    use lib_ruby_parser_nodes::NodeFieldType;

    match field.field_type {
        NodeFieldType::Node => "Ptr<Node>",
        NodeFieldType::Nodes => "List<Node>",
        NodeFieldType::MaybeNode => "MaybePtr<Node>",
        NodeFieldType::Loc => "Loc",
        NodeFieldType::MaybeLoc => "MaybeLoc",
        NodeFieldType::Str => "StringPtr",
        NodeFieldType::MaybeStr => "MaybeStringPtr",
        NodeFieldType::Chars => "MaybeStringPtr",
        NodeFieldType::StringValue => "StringValue",
        NodeFieldType::U8 => "u8",
        NodeFieldType::Usize => "usize",
        NodeFieldType::RawString => "StringPtr",
        NodeFieldType::RegexOptions => "MaybePtr<Node>",
    }
}

fn field_declaration(field: &lib_ruby_parser_nodes::NodeField) -> String {
    format!(
        "#[allow(dead_code)]
    pub(crate) {field_name}: {field_type},",
        field_name = field.field_name,
        field_type = field_type(field)
    )
}
