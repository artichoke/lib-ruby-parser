use lib_ruby_parser_nodes::{template::*, MessageField};

const TEMPLATE: &str = "// This file is auto-generated by {{ helper generated-by }}

use super::DiagnosticMessage;

{{ each message }}<dnl>
#[test]
fn test_{{ helper message-lower-name }}() {
    let message = DiagnosticMessage::new_{{ helper message-lower-name }}(
{{ each message-field }}<dnl>
        {{ helper new-field-fn }}(),
{{ end }}<dnl>
    );
    let variant = message.as_{{ helper message-lower-name }}().unwrap();
{{ each message-field }}<dnl>
    assert_eq!(variant.get_{{ helper message-field-name }}(), &{{ helper new-field-fn }}());
{{ end }}<dnl>
    drop(variant);
    drop(message);
}
{{ end }}<dnl>

fn new_str() -> String {
    String::from(String::from(\"foo\"))
}
fn new_byte() -> u8 {
    42
}
";

pub(crate) fn codegen() {
    let template = TemplateRoot::new(TEMPLATE).unwrap();
    let mut fns = crate::codegen::fns::default_fns!();

    fns.register::<MessageField, F::Helper>("new-field-fn", local_helpers::new_field_fn);

    let contents = template.render(ALL_DATA, &fns);
    std::fs::write("src/error/message/tests.rs", contents).unwrap();
}

mod local_helpers {
    pub(crate) fn new_field_fn(message_field: &lib_ruby_parser_nodes::MessageField) -> String {
        match message_field.field_type {
            lib_ruby_parser_nodes::MessageFieldType::Str => "new_str",
            lib_ruby_parser_nodes::MessageFieldType::Byte => "new_byte",
        }
        .to_string()
    }
}
