fn contents() -> String {
    let messages = lib_ruby_parser_nodes::messages().messages();

    format!(
        "// This file is autogenerated by {generator}

use super::DiagnosticMessage;

impl DiagnosticMessage {{
    {getters}
}}
",
        generator = file!(),
        getters = messages.flat_map(&getters).join("\n    ")
    )
}

pub(crate) fn codegen() {
    std::fs::write("src/error/message/native/getters.rs", contents()).unwrap();
}

fn getters(message: &lib_ruby_parser_nodes::Message) -> Vec<String> {
    message.fields.map(&|field| {
        let return_type = match field.field_type {
            lib_ruby_parser_nodes::MessageFieldType::Str => "&String",
            lib_ruby_parser_nodes::MessageFieldType::Byte => "u8",
        };

        let get_field = match field.field_type {
            lib_ruby_parser_nodes::MessageFieldType::Str => format!("{}", field.name),
            lib_ruby_parser_nodes::MessageFieldType::Byte => format!("*{}", field.name),
        };

        format!(
            "pub(crate) fn {prefix}_get_{field_name}(&self) -> {return_type} {{
                if let Self::{variant_name} {{ {field_name}, .. }} = self {{
                    {get_field}
                }} else {{
                    panic!(\"self is not {variant_name}\")
                }}
            }}",
            prefix = message.lower_name(),
            field_name = field.name,
            get_field = get_field,
            return_type = return_type,
            variant_name = message.camelcase_name()
        )
    })
}
