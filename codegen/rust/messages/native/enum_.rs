fn contents() -> String {
    let sections = lib_ruby_parser_nodes::message_sections();

    format!(
        "// This file is autogenerated by {generator}

/// Enum of all possible diagnostic message (both warnings and errors)
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DiagnosticMessage {{
    {all_variants}
}}
",
        generator = file!(),
        all_variants = sections.map(&section_variants).join("\n    ")
    )
}

pub(crate) fn codegen() {
    std::fs::write("src/error/message/native/enum_.rs", contents()).unwrap();
}

fn section_variants(section: &lib_ruby_parser_nodes::Section) -> String {
    let variants = section.messages.map(&message_variant);

    format!(
        "/* {section_name} */

{variants}",
        section_name = section.name,
        variants = variants.join("\n\n")
    )
}

fn message_variant(message: &lib_ruby_parser_nodes::Message) -> String {
    let fields = {
        let fields = message.fields.map(&|field| {
            let field_type = match field.field_type {
                lib_ruby_parser_nodes::MessageFieldType::Str => "String",
                lib_ruby_parser_nodes::MessageFieldType::Byte => "u8",
            };

            format!(
                "{comment}
            {field_name}: {field_type},",
                comment = field.render_comment("///", 8),
                field_name = field.name,
                field_type = field_type,
            )
        });

        if fields.is_empty() {
            format!("")
        } else {
            format!(
                " {{
        {}
        }}",
                fields.join("\n\n")
            )
        }
    };

    format!(
        "{comment}
{variant}{fields},",
        comment = message.render_comment("///", 4),
        variant = message.camelcase_name(),
        fields = fields
    )
}
